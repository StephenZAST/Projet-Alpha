import { getAdmin, createAdmin, updateAdmin, deleteAdmin, AdminRole, IAdmin } from '../models/admin';
import { hashPassword, comparePassword } from '../utils/auth';
import { generateToken } from '../utils/jwt';
import { AppError } from '../utils/errors';
import { errorCodes } from '../utils/errors';
import { db } from '../config/firebase'; // Import db

export class AdminService {
  // Create an admin account (only by super admin)
  async createAdmin(adminData: Partial<IAdmin>, creatorId: string): Promise<IAdmin> {
    const creator = await getAdmin(creatorId);
    if (!creator || (creator.role !== AdminRole.SUPER_ADMIN_MASTER && creator.role !== AdminRole.SUPER_ADMIN)) {
      throw new AppError(403, "Not authorized to create admins", errorCodes.FORBIDDEN);
    }

    // Check if attempting to create a master super admin
    if (adminData.role === AdminRole.SUPER_ADMIN_MASTER) {
      throw new AppError(403, "Cannot create another Master Super Admin", errorCodes.FORBIDDEN);
    }

    // Only the master admin can create a super admin
    if (adminData.role === AdminRole.SUPER_ADMIN && creator.role !== AdminRole.SUPER_ADMIN_MASTER) {
      throw new AppError(403, "Only the Master Super Admin can create other Super Admins", errorCodes.FORBIDDEN);
    }

    // Check if password is defined before hashing
    const hashedPassword = adminData.password ? await hashPassword(adminData.password) : undefined;

    const newAdminData: IAdmin = {
      ...adminData,
      password: hashedPassword || '', // Ensure password is a string
      createdBy: creatorId,
      _id: '', // _id will be generated by Firebase
      userId: adminData.userId || '', // Ensure userId is a string
      email: adminData.email || '', // Ensure email is a string
      firstName: adminData.firstName || '', // Ensure firstName is a string
      lastName: adminData.lastName || '', // Ensure lastName is a string
      phoneNumber: adminData.phoneNumber || '', // Ensure phoneNumber is a string
      isActive: adminData.isActive ?? true, // Default to true if not provided
      lastLogin: adminData.lastLogin || undefined,
      createdAt: new Date(),
      updatedAt: new Date(),
      permissions: adminData.permissions || [],
      isMasterAdmin: adminData.isMasterAdmin || false,
      role: adminData.role || AdminRole.SECRETARY, // Provide default role
    };

    return await createAdmin(newAdminData); // Use Firebase createAdmin function
  }

  // Admin login
  async loginAdmin(email: string, password: string): Promise<{ admin: IAdmin; token: string }> {
    const admin = await this.getAdminByEmail(email); // Use this.getAdminByEmail
    if (!admin || !admin.isActive) {
      throw new AppError(401, "Incorrect email or password", errorCodes.UNAUTHORIZED);
    }

    const isValidPassword = await comparePassword(password, admin.password);
    if (!isValidPassword) {
      throw new AppError(401, "Incorrect email or password", errorCodes.UNAUTHORIZED);
    }

    // Update lastLogin using Firebase updateAdmin function
    await updateAdmin(admin._id, { lastLogin: new Date() });

    const token = generateToken(admin);

    return { admin, token };
  }

  // Update an admin
  async updateAdmin(adminId: string, updates: Partial<IAdmin>, updaterId: string): Promise<IAdmin> {
    const updater = await getAdmin(updaterId);
    const adminToUpdate = await getAdmin(adminId);

    if (!updater || !adminToUpdate) {
      throw new AppError(404, "Admin not found", errorCodes.NOT_FOUND);
    }

    // Security checks
    if (adminToUpdate.isMasterAdmin) {
      throw new AppError(403, "The Master Admin account cannot be modified", errorCodes.FORBIDDEN);
    }

    if (updates.role === AdminRole.SUPER_ADMIN_MASTER) {
      throw new AppError(403, "Cannot promote to Master Super Admin", errorCodes.FORBIDDEN);
    }

    // Only the master admin can modify a super admin
    if (adminToUpdate.role === AdminRole.SUPER_ADMIN && updater.role !== AdminRole.SUPER_ADMIN_MASTER) {
      throw new AppError(403, "Only the Master Super Admin can modify a Super Admin", errorCodes.FORBIDDEN);
    }

    // Check if password is defined before hashing
    if (updates.password) {
      updates.password = await hashPassword(updates.password);
    }

    return await updateAdmin(adminId, updates); // Use Firebase updateAdmin function
  }

  // Delete an admin
  async deleteAdmin(adminId: string, deleterId: string): Promise<void> {
    const deleter = await getAdmin(deleterId);
    const adminToDelete = await getAdmin(adminId);

    if (!deleter || !adminToDelete) {
      throw new AppError(404, "Admin not found", errorCodes.NOT_FOUND);
    }

    // Security checks
    if (adminToDelete.isMasterAdmin) {
      throw new AppError(403, "The Master Admin account cannot be deleted", errorCodes.FORBIDDEN);
    }

    if (adminToDelete.role === AdminRole.SUPER_ADMIN && deleter.role !== AdminRole.SUPER_ADMIN_MASTER) {
      throw new AppError(403, "Only the Master Super Admin can delete a Super Admin", errorCodes.FORBIDDEN);
    }

    await deleteAdmin(adminId); // Use Firebase deleteAdmin function
  }

  // Get all admins (for super admin only)
  async getAllAdmins(requesterId: string): Promise<IAdmin[]> {
    const requester = await getAdmin(requesterId);
    if (!requester || (requester.role !== AdminRole.SUPER_ADMIN_MASTER && requester.role !== AdminRole.SUPER_ADMIN)) {
      throw new AppError(403, "Not authorized to view all admins", errorCodes.FORBIDDEN);
    }

    // Implement Firebase equivalent of Admin.find().select('-password')
    const adminsSnapshot = await db.collection('admins').get();
    return adminsSnapshot.docs.map((doc: FirebaseFirestore.QueryDocumentSnapshot) => { // Explicitly type doc
      const admin = doc.data() as IAdmin;
      // delete admin.password; // No need to delete, password is already optional
      return admin;
    });
  }

  // Get an admin by ID
  async getAdminById(adminId: string, requesterId: string): Promise<IAdmin> {
    const requester = await getAdmin(requesterId);
    const admin = await getAdmin(adminId);

    if (!requester || !admin) {
      throw new AppError(404, "Admin not found", errorCodes.NOT_FOUND);
    }

    // Only super admins can view details of other admins
    if (requesterId !== adminId && 
        requester.role !== AdminRole.SUPER_ADMIN_MASTER && 
        requester.role !== AdminRole.SUPER_ADMIN) {
      throw new AppError(403, "Not authorized to view details of this admin", errorCodes.FORBIDDEN);
    }

    // delete admin.password; // No need to delete, password is already optional
    return admin;
  }

  // Change the active/inactive status of an admin
  async toggleAdminStatus(adminId: string, isActive: boolean, requesterId: string): Promise<IAdmin> {
    const requester = await getAdmin(requesterId);
    const adminToUpdate = await getAdmin(adminId);

    if (!requester || !adminToUpdate) {
      throw new AppError(404, "Admin not found", errorCodes.NOT_FOUND);
    }

    if (adminToUpdate.isMasterAdmin) {
      throw new AppError(403, "The Master Admin account cannot be deactivated", errorCodes.FORBIDDEN);
    }

    if (adminToUpdate.role === AdminRole.SUPER_ADMIN && requester.role !== AdminRole.SUPER_ADMIN_MASTER) {
      throw new AppError(403, "Only the Master Super Admin can modify the status of a Super Admin", errorCodes.FORBIDDEN);
    }

    // Update isActive using Firebase updateAdmin function
    return await updateAdmin(adminId, { isActive });
  }

  // Create the initial Master Super Admin account (should only be used once)
  async createMasterAdmin(adminData: Partial<IAdmin>): Promise<IAdmin> {
    const existingMaster = await db.collection('admins').where('isMasterAdmin', '==', true).get();
    if (!existingMaster.empty) {
      throw new AppError(403, "A Master Super Admin already exists", errorCodes.FORBIDDEN);
    }

    // Check if password is defined before hashing
    const hashedPassword = adminData.password ? await hashPassword(adminData.password) : undefined;

    const masterAdminData: IAdmin = {
      ...adminData,
      role: AdminRole.SUPER_ADMIN_MASTER,
      isMasterAdmin: true,
      password: hashedPassword || '', // Ensure password is a string
      createdBy: 'SYSTEM',
      _id: '', // _id will be generated by Firebase
      userId: adminData.userId || '', // Ensure userId is a string
      email: adminData.email || '', // Ensure email is a string
      firstName: adminData.firstName || '', // Ensure firstName is a string
      lastName: adminData.lastName || '', // Ensure lastName is a string
      phoneNumber: adminData.phoneNumber || '', // Ensure phoneNumber is a string
      isActive: adminData.isActive ?? true, // Default to true if not provided
      lastLogin: adminData.lastLogin || undefined,
      createdAt: new Date(),
      updatedAt: new Date(),
      permissions: adminData.permissions || [],
    };

    return await createAdmin(masterAdminData); // Use Firebase createAdmin function
  }

  // Helper function to get admin by email
  async getAdminByEmail(email: string): Promise<IAdmin | null> {
    const adminSnapshot = await db.collection('admins').where('email', '==', email).get();
    if (adminSnapshot.empty) {
      return null;
    }
    return adminSnapshot.docs[0].data() as IAdmin;
  }
}
