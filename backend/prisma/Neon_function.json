[{
  "Info": "=== archive_article ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.archive_article(article_id_param uuid)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    INSERT INTO article_archives \n    SELECT *, CURRENT_TIMESTAMP as archived_at \n    FROM articles \n    WHERE id = article_id_param;\n    \n    DELETE FROM articles WHERE id = article_id_param;\n    RETURN FOUND;\nEND;\n$function$\n"
}, {
  "Info": "=== calculate_order_total ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.calculate_order_total(order_id_param uuid)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN COALESCE((\r\n        SELECT SUM(quantity * \"unitPrice\")\r\n        FROM order_items\r\n        WHERE \"orderId\" = order_id_param\r\n    ), 0);\r\nEND;\r\n$function$\n"
}, {
  "Info": "=== calculate_service_price ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.calculate_service_price(article_id uuid, service_type_id uuid, weight numeric DEFAULT NULL::numeric)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    base_price numeric;\nBEGIN\n    -- Récupérer le prix spécifique à l'article et au service\n    SELECT price INTO base_price\n    FROM article_service_prices\n    WHERE article_id = $1 AND service_type_id = $2;\n\n    -- Si pas de prix spécifique et poids fourni, calculer basé sur le poids\n    IF base_price IS NULL AND weight IS NOT NULL THEN\n        base_price := calculate_weight_price(weight, service_type_id);\n    END IF;\n\n    RETURN base_price;\nEND;\n$function$\n"
}, {
  "Info": "=== calculate_weight_price ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.calculate_weight_price(weight numeric, service_type_id uuid)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN (\n        SELECT price \n        FROM weight_based_pricing \n        WHERE min_weight <= weight \n        AND max_weight > weight \n        AND service_type_id = $2\n        LIMIT 1\n    );\nEND;\n$function$\n"
}, {
  "Info": "=== create_flash_order ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.create_flash_order(order_data jsonb, note_text text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    new_order_id uuid;\n    created_order jsonb;\nBEGIN\n    -- Insérer la commande avec statut DRAFT\n    INSERT INTO orders (\n        \"userId\",\n        \"serviceId\",\n        \"addressId\",\n        status,\n        total,\n        created_at,\n        updated_at\n    )\n    SELECT \n        (order_data->>'userId')::uuid,\n        (order_data->>'serviceId')::uuid,\n        (order_data->>'addressId')::uuid,\n        'DRAFT',\n        0,\n        CURRENT_TIMESTAMP,\n        CURRENT_TIMESTAMP\n    RETURNING id INTO new_order_id;\n\n    -- Insérer la note si fournie\n    IF note_text IS NOT NULL THEN\n        INSERT INTO order_notes (\n            order_id,\n            note,\n            created_at,\n            updated_at\n        ) VALUES (\n            new_order_id,\n            note_text,\n            CURRENT_TIMESTAMP,\n            CURRENT_TIMESTAMP\n        );\n    END IF;\n\n    -- Récupérer la commande créée\n    SELECT jsonb_build_object(\n        'id', o.id,\n        'userId', o.\"userId\",\n        'serviceId', o.\"serviceId\",\n        'addressId', o.\"addressId\",\n        'status', o.status,\n        'total', o.total,\n        'note', n.note\n    ) INTO created_order\n    FROM orders o\n    LEFT JOIN order_notes n ON n.order_id = o.id\n    WHERE o.id = new_order_id;\n\n    RETURN created_order;\nEND;\n$function$\n"
}, {
  "Info": "=== create_flash_order_with_metadata ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.create_flash_order_with_metadata(order_data jsonb, metadata jsonb, note_text text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    new_order_id uuid;\n    created_order jsonb;\nBEGIN\n    -- Créer la commande flash\n    created_order := create_flash_order(order_data, note_text);\n    new_order_id := (created_order->>'id')::uuid;\n\n    -- Ajouter les métadonnées\n    IF metadata IS NOT NULL THEN\n        UPDATE orders\n        SET metadata = metadata\n        WHERE id = new_order_id;\n    END IF;\n\n    -- Retourner la commande mise à jour\n    SELECT jsonb_build_object(\n        'id', o.id,\n        'userId', o.\"userId\",\n        'serviceId', o.\"serviceId\",\n        'addressId', o.\"addressId\",\n        'status', o.status,\n        'total', o.total,\n        'metadata', o.metadata,\n        'note', n.note\n    ) INTO created_order\n    FROM orders o\n    LEFT JOIN order_notes n ON n.order_id = o.id\n    WHERE o.id = new_order_id;\n\n    RETURN created_order;\nEND;\n$function$\n"
}, {
  "Info": "=== format_status ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.format_status(is_done boolean)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN CASE WHEN is_done THEN '✅' ELSE '❌' END;\nEND;\n$function$\n"
}, {
  "Info": "=== generate_functions_documentation ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.generate_functions_documentation()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    doc text := '# Documentation des Fonctions PostgreSQL' || E'\\n\\n';\r\n    func record;\r\n    current_level text := '';\r\nBEGIN\r\n    FOR func IN (\r\n        SELECT \r\n            n.nspname as schema,\r\n            p.proname as name,\r\n            pg_get_function_result(p.oid) as return_type,\r\n            pg_get_function_arguments(p.oid) as arguments,\r\n            d.description,\r\n            CASE \r\n                WHEN p.proname LIKE '%order%' THEN 'Gestion des Commandes'\r\n                WHEN p.proname LIKE '%article%' THEN 'Gestion des Articles'\r\n                WHEN p.proname LIKE '%loyalty%' THEN 'Gestion de la Fidélité'\r\n                WHEN p.proname LIKE '%affiliate%' THEN 'Gestion des Affiliés'\r\n                WHEN p.proname LIKE '%service%' THEN 'Gestion des Services'\r\n                ELSE 'Autres Fonctions'\r\n            END as category,\r\n            pg_get_functiondef(p.oid) as definition\r\n        FROM pg_proc p\r\n        LEFT JOIN pg_description d ON p.oid = d.objoid\r\n        LEFT JOIN pg_namespace n ON n.oid = p.pronamespace\r\n        WHERE n.nspname = 'public'\r\n        ORDER BY category, p.proname\r\n    )\r\n    LOOP\r\n        -- Ajouter un séparateur de catégorie si nécessaire\r\n        IF current_level != func.category THEN\r\n            current_level := func.category;\r\n            doc := doc || E'\\n## ' || current_level || E'\\n\\n';\r\n        END IF;\r\n\r\n        -- Ajouter les détails de la fonction\r\n        doc := doc || E'### `' || func.name || '`\\n\\n';\r\n        doc := doc || '**Signature:**\\n```sql\\n' || \r\n               func.name || '(' || func.arguments || ') RETURNS ' || func.return_type || \r\n               E'\\n```\\n\\n';\r\n\r\n        -- Description si disponible\r\n        IF func.description IS NOT NULL THEN\r\n            doc := doc || '**Description:**\\n' || func.description || E'\\n\\n';\r\n        END IF;\r\n\r\n        -- Ajouter le code source de la fonction\r\n        doc := doc || '**Implémentation:**\\n```sql\\n' || \r\n               func.definition || E'\\n```\\n\\n';\r\n\r\n        -- Ajouter un exemple d'utilisation\r\n        doc := doc || '**Exemple d''utilisation:**\\n```sql\\n';\r\n        CASE func.name\r\n            WHEN 'calculate_order_total' THEN\r\n                doc := doc || 'SELECT calculate_order_total(''uuid-de-commande'');';\r\n            WHEN 'get_paginated_orders' THEN\r\n                doc := doc || 'SELECT * FROM get_paginated_orders(1, 10, ''PENDING'', ''created_at'', ''desc'');';\r\n            ELSE\r\n                doc := doc || '-- Exemple à venir';\r\n        END CASE;\r\n        doc := doc || E'\\n```\\n\\n';\r\n\r\n        -- Ajouter un séparateur\r\n        doc := doc || '---\\n\\n';\r\n    END LOOP;\r\n\r\n    RETURN doc;\r\nEND;\r\n$function$\n"
}, {
  "Info": "=== get_paginated_orders ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.get_paginated_orders(p_page integer, p_limit integer, p_status text DEFAULT NULL::text, p_sort_field text DEFAULT 'created_at'::text, p_sort_order text DEFAULT 'desc'::text)\n RETURNS TABLE(data jsonb, total_count bigint)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    v_offset integer;\n    v_where text := 'WHERE 1=1';\n    v_order_by text;\nBEGIN\n    -- Calculer l'offset\n    v_offset := (p_page - 1) * p_limit;\n\n    -- Ajouter le filtre de statut si fourni\n    IF p_status IS NOT NULL THEN\n        v_where := v_where || format(' AND status = %L', p_status);\n    END IF;\n\n    -- Construire ORDER BY\n    v_order_by := format(' ORDER BY %I %s', p_sort_field, p_sort_order);\n\n    -- Retourner les résultats\n    RETURN QUERY EXECUTE format('\n        WITH ordered_orders AS (\n            SELECT \n                jsonb_build_object(\n                    ''id'', o.id,\n                    ''userId'', o.\"userId\",\n                    ''serviceId'', o.\"serviceId\",\n                    ''addressId'', o.\"addressId\",\n                    ''status'', o.status,\n                    ''total'', o.total,\n                    ''createdAt'', o.created_at,\n                    ''updatedAt'', o.updated_at,\n                    ''items'', COALESCE(\n                        jsonb_agg(\n                            jsonb_build_object(\n                                ''id'', oi.id,\n                                ''articleId'', oi.\"articleId\",\n                                ''quantity'', oi.quantity,\n                                ''unitPrice'', oi.\"unitPrice\"\n                            )\n                        ) FILTER (WHERE oi.id IS NOT NULL),\n                        ''[]''::jsonb\n                    )\n                ) as order_data\n            FROM orders o\n            LEFT JOIN order_items oi ON o.id = oi.\"orderId\"\n            %s\n            GROUP BY o.id\n            %s\n            LIMIT %s OFFSET %s\n        )\n        SELECT \n            array_to_json(array_agg(order_data))::jsonb as data,\n            (SELECT COUNT(*) FROM orders o %s) as total_count\n        FROM ordered_orders;\n    ', v_where, v_order_by, p_limit, v_offset, v_where);\nEND;\n$function$\n"
}, {
  "Info": "=== get_table_structure ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.get_table_structure(table_name text)\n RETURNS TABLE(column_name text, data_type text, is_nullable boolean, column_default text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        c.column_name::text,\n        c.data_type::text,\n        c.is_nullable::boolean,\n        c.column_default::text\n    FROM information_schema.columns c\n    WHERE c.table_schema = 'public'\n    AND c.table_name = $1\n    ORDER BY c.ordinal_position;\nEND;\n$function$\n"
}, {
  "Info": "=== increment_referral_count ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.increment_referral_count()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    IF NEW.referrer_id IS NOT NULL THEN\n        UPDATE users\n        SET referral_count = referral_count + 1\n        WHERE id = NEW.referrer_id;\n    END IF;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== initialize_default_pricing ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.initialize_default_pricing(article_id_param uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    INSERT INTO article_service_prices (\n        article_id, \n        service_type_id, \n        price, \n        created_at, \n        updated_at\n    )\n    SELECT \n        article_id_param,\n        st.id,\n        0,\n        CURRENT_TIMESTAMP,\n        CURRENT_TIMESTAMP\n    FROM service_types st\n    WHERE NOT EXISTS (\n        SELECT 1 FROM article_service_prices\n        WHERE article_id = article_id_param\n        AND service_type_id = st.id\n    );\nEND;\n$function$\n"
}, {
  "Info": "=== initialize_user_loyalty_points ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.initialize_user_loyalty_points()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    INSERT INTO loyalty_points (\r\n        id,\r\n        user_id,\r\n        \"pointsBalance\",\r\n        \"totalEarned\",\r\n        \"createdAt\",\r\n        \"updatedAt\"\r\n    )\r\n    VALUES (\r\n        gen_random_uuid(),\r\n        NEW.id,\r\n        0,\r\n        0,\r\n        CURRENT_TIMESTAMP,\r\n        CURRENT_TIMESTAMP\r\n    );\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "Info": "=== insert_flash_order_note ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.insert_flash_order_note()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    INSERT INTO order_notes (\n        order_id,\n        note,\n        created_at,\n        updated_at\n    ) VALUES (\n        NEW.id,\n        'Commande flash créée',\n        CURRENT_TIMESTAMP,\n        CURRENT_TIMESTAMP\n    );\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== list_functions ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.list_functions()\n RETURNS TABLE(function_name text, return_type text, argument_types text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        p.proname::text,\n        pg_get_function_result(p.oid)::text,\n        pg_get_function_arguments(p.oid)::text\n    FROM pg_proc p\n    JOIN pg_namespace n ON p.pronamespace = n.oid\n    WHERE n.nspname = 'public';\nEND;\n$function$\n"
}, {
  "Info": "=== list_procedures ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.list_procedures()\n RETURNS TABLE(procedure_name text, argument_types text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        p.proname::text,\n        pg_get_function_arguments(p.oid)::text\n    FROM pg_proc p\n    JOIN pg_namespace n ON p.pronamespace = n.oid\n    WHERE n.nspname = 'public'\n    AND p.prokind = 'p';\nEND;\n$function$\n"
}, {
  "Info": "=== list_triggers ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.list_triggers()\n RETURNS TABLE(trigger_name text, table_name text, event_type text, function_name text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        t.tgname::text,\n        c.relname::text,\n        CASE \n            WHEN t.tgtype & 2 > 0 THEN 'BEFORE'\n            WHEN t.tgtype & 16 > 0 THEN 'AFTER'\n            ELSE 'UNKNOWN'\n        END::text,\n        p.proname::text\n    FROM pg_trigger t\n    JOIN pg_class c ON t.tgrelid = c.oid\n    JOIN pg_proc p ON t.tgfoid = p.oid\n    WHERE c.relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public');\nEND;\n$function$\n"
}, {
  "Info": "=== log_change ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.log_change(message text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RAISE NOTICE '%', message;\r\nEND;\r\n$function$\n"
}, {
  "Info": "=== migrate_article_prices ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.migrate_article_prices()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    INSERT INTO article_service_prices (\n        article_id, \n        service_type_id, \n        price, \n        created_at, \n        updated_at\n    )\n    SELECT \n        a.id,\n        st.id,\n        a.price,\n        CURRENT_TIMESTAMP,\n        CURRENT_TIMESTAMP\n    FROM articles a\n    CROSS JOIN service_types st\n    WHERE NOT EXISTS (\n        SELECT 1 FROM article_service_prices asp\n        WHERE asp.article_id = a.id\n        AND asp.service_type_id = st.id\n    );\nEND;\n$function$\n"
}, {
  "Info": "=== reset_monthly_earnings ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.reset_monthly_earnings()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    UPDATE affiliate_profiles\n    SET monthly_earnings = 0,\n        updated_at = CURRENT_TIMESTAMP;\nEND;\n$function$\n"
}, {
  "Info": "=== sync_order_note ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.sync_order_note()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    IF TG_OP = 'INSERT' THEN\n        UPDATE orders \n        SET updated_at = CURRENT_TIMESTAMP\n        WHERE id = NEW.order_id;\n    ELSIF TG_OP = 'UPDATE' THEN\n        IF OLD.note <> NEW.note THEN\n            UPDATE orders \n            SET updated_at = CURRENT_TIMESTAMP\n            WHERE id = NEW.order_id;\n        END IF;\n    END IF;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== trigger_set_timestamp ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.trigger_set_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== trigger_update_affiliate_level ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.trigger_update_affiliate_level()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Mise à jour du niveau basé sur les gains\n    UPDATE affiliate_profiles\n    SET level_id = (\n        SELECT id \n        FROM affiliate_levels \n        WHERE minimum_earnings <= NEW.total_earned \n        ORDER BY minimum_earnings DESC \n        LIMIT 1\n    )\n    WHERE id = NEW.id;\n    \n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== update_article_services ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.update_article_services()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    UPDATE article_service_compatibility\n    SET updated_at = CURRENT_TIMESTAMP;\nEND;\n$function$\n"
}, {
  "Info": "=== update_article_services ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.update_article_services(article_id_param uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    UPDATE article_service_compatibility\n    SET updated_at = CURRENT_TIMESTAMP\n    WHERE article_id = article_id_param;\nEND;\n$function$\n"
}, {
  "Info": "=== update_loyalty_points_balance ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.update_loyalty_points_balance()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Mise à jour du solde de points\n    UPDATE loyalty_points\n    SET \"pointsBalance\" = \"pointsBalance\" + NEW.amount,\n        updated_at = CURRENT_TIMESTAMP\n    WHERE \"userId\" = NEW.\"userId\";\n\n    -- Vérification du nouveau solde\n    IF EXISTS (\n        SELECT 1 \n        FROM loyalty_points \n        WHERE \"userId\" = NEW.\"userId\" \n        AND \"pointsBalance\" < 0\n    ) THEN\n        RAISE EXCEPTION 'Le solde de points ne peut pas être négatif';\n    END IF;\n    \n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== update_loyalty_points_timestamp ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.update_loyalty_points_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.\"updatedAt\" = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== update_loyalty_points_updated_at ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.update_loyalty_points_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== update_order_items_updated_at ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.update_order_items_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== update_order_total ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.update_order_total()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    UPDATE orders\r\n    SET total = calculate_order_total(NEW.\"orderId\"),\r\n        updated_at = CURRENT_TIMESTAMP\r\n    WHERE id = NEW.\"orderId\";\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "Info": "=== update_orders_timestamp ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.update_orders_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== update_service_timestamps ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.update_service_timestamps()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.updated_at = CURRENT_TIMESTAMP;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "Info": "=== update_timestamp ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.update_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    IF TG_OP = 'UPDATE' THEN\r\n        NEW.updated_at = CURRENT_TIMESTAMP;\r\n    ELSE\r\n        -- Pour INSERT\r\n        NEW.created_at = COALESCE(NEW.created_at, CURRENT_TIMESTAMP);\r\n        NEW.updated_at = CURRENT_TIMESTAMP;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "Info": "=== update_timestamp_column ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.update_timestamp_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== update_updated_at_column ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.updated_at = CURRENT_TIMESTAMP;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "Info": "=== validate_article_service_price ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.validate_article_service_price()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Validation du prix de base\n    IF NEW.base_price < 0 THEN\n        RAISE EXCEPTION 'Le prix de base ne peut pas être négatif';\n    END IF;\n\n    -- Validation du prix premium\n    IF NEW.premium_price IS NOT NULL AND NEW.premium_price < 0 THEN\n        RAISE EXCEPTION 'Le prix premium ne peut pas être négatif';\n    END IF;\n\n    -- Validation du prix au kilo pour WEIGHT_BASED\n    IF NEW.pricing_type = 'WEIGHT_BASED' AND NEW.price_per_kg IS NULL THEN\n        RAISE EXCEPTION 'Prix au kilo requis pour le type WEIGHT_BASED';\n    END IF;\n\n    -- Mise à jour timestamp\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    \n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== validate_article_service_price_constraint ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.validate_article_service_price_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Vérification du type de prix\r\n    IF NEW.pricing_type NOT IN ('FIXED', 'WEIGHT_BASED', 'CUSTOM') THEN\r\n        RAISE EXCEPTION 'Type de prix invalide. Doit être FIXED, WEIGHT_BASED, ou CUSTOM';\r\n    END IF;\r\n\r\n    -- Vérification des prix négatifs\r\n    IF NEW.base_price < 0 OR (NEW.premium_price IS NOT NULL AND NEW.premium_price < 0) THEN\r\n        RAISE EXCEPTION 'Les prix ne peuvent pas être négatifs';\r\n    END IF;\r\n\r\n    -- Vérification du prix au kilo si applicable\r\n    IF NEW.pricing_type = 'WEIGHT_BASED' AND (NEW.price_per_kg IS NULL OR NEW.price_per_kg <= 0) THEN\r\n        RAISE EXCEPTION 'Prix au kilo requis et doit être positif pour le type WEIGHT_BASED';\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "Info": "=== validate_loyalty_points ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.validate_loyalty_points()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Validation du solde\n    IF NEW.\"pointsBalance\" < 0 THEN\n        RAISE EXCEPTION 'Le solde de points ne peut pas être négatif';\n    END IF;\n\n    -- Validation du total gagné\n    IF NEW.\"totalEarned\" < NEW.\"pointsBalance\" THEN\n        RAISE EXCEPTION 'Le solde ne peut pas dépasser le total gagné';\n    END IF;\n\n    -- Pas de mise à jour de timestamp - géré par Prisma\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== validate_loyalty_points_constraint ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.validate_loyalty_points_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Vérification du solde de points positif\n    IF NEW.\"pointsBalance\" < 0 THEN\n        RAISE EXCEPTION 'Le solde de points ne peut pas être négatif';\n    END IF;\n\n    -- Vérification du total des points gagnés\n    IF NEW.\"totalEarned\" < 0 THEN\n        RAISE EXCEPTION 'Le total des points gagnés ne peut pas être négatif';\n    END IF;\n\n    -- Vérification de la cohérence\n    IF NEW.\"pointsBalance\" > NEW.\"totalEarned\" THEN\n        RAISE EXCEPTION 'Le solde actuel ne peut pas dépasser le total des points gagnés';\n    END IF;\n\n    -- Mise à jour automatique du timestamp en camelCase\n    NEW.\"updatedAt\" = CURRENT_TIMESTAMP;\n    \n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== validate_order_items_constraint ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.validate_order_items_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Vérification de la quantité\n    IF NEW.quantity <= 0 THEN\n        RAISE EXCEPTION 'La quantité doit être supérieure à zéro';\n    END IF;\n\n    -- Vérification du prix unitaire\n    IF NEW.\"unitPrice\" <= 0 THEN\n        RAISE EXCEPTION 'Le prix unitaire doit être supérieur à zéro';\n    END IF;\n\n    -- Vérification du poids si applicable\n    IF NEW.weight IS NOT NULL AND NEW.weight <= 0 THEN\n        RAISE EXCEPTION 'Le poids doit être supérieur à zéro';\n    END IF;\n\n    -- Calcul automatique du total\n    NEW.total = NEW.quantity * NEW.\"unitPrice\";\n    \n    -- Mise à jour du timestamp\n    NEW.updated_at = CURRENT_TIMESTAMP;\n\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== validate_price_ranges_constraint ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.validate_price_ranges_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Vérification du prix de base\r\n    IF NEW.base_price IS NOT NULL AND NEW.base_price < 0 THEN\r\n        RAISE EXCEPTION 'Le prix de base ne peut pas être négatif';\r\n    END IF;\r\n\r\n    -- Vérification du prix premium\r\n    IF NEW.premium_price IS NOT NULL AND NEW.premium_price < 0 THEN\r\n        RAISE EXCEPTION 'Le prix premium ne peut pas être négatif';\r\n    END IF;\r\n\r\n    -- Vérification de la cohérence des prix\r\n    IF NEW.premium_price IS NOT NULL AND NEW.base_price IS NOT NULL THEN\r\n        IF NEW.premium_price <= NEW.base_price THEN\r\n            RAISE EXCEPTION 'Le prix premium doit être supérieur au prix de base';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Mise à jour automatique des timestamps\r\n    NEW.created_at = COALESCE(NEW.created_at, CURRENT_TIMESTAMP);\r\n    NEW.updated_at = CURRENT_TIMESTAMP;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "Info": "=== validate_service_types_constraint ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.validate_service_types_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    IF NEW.pricing_type NOT IN ('FIXED', 'WEIGHT_BASED', 'CUSTOM') THEN\r\n        RAISE NOTICE 'Invalid pricing_type: %', NEW.pricing_type;\r\n        RAISE EXCEPTION 'Invalid pricing type. Must be FIXED, WEIGHT_BASED, or CUSTOM';\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "Info": "=== validate_weight_pricing ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.validate_weight_pricing()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Validation des poids selon les valeurs par défaut du schema\n    IF NEW.min_weight < 0 THEN\n        RAISE EXCEPTION 'Le poids minimum doit être positif';\n    END IF;\n\n    IF NEW.max_weight <= NEW.min_weight THEN\n        RAISE EXCEPTION 'Le poids maximum doit être supérieur au minimum';\n    END IF;\n\n    IF NEW.max_weight > 999999 THEN\n        RAISE EXCEPTION 'Le poids maximum ne peut pas dépasser 999999';\n    END IF;\n\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "Info": "=== validate_weight_range_constraint ===",
  "Définition": "CREATE OR REPLACE FUNCTION public.validate_weight_range_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Log de début de validation\n    RAISE NOTICE 'Validation des plages de poids pour ID: %', NEW.id;\n\n    -- Vérification des valeurs minimales\n    IF NEW.min_weight IS NULL OR NEW.min_weight < 0 THEN\n        RAISE EXCEPTION 'Le poids minimum doit être positif';\n    END IF;\n\n    -- Vérification des valeurs maximales\n    IF NEW.max_weight IS NULL OR NEW.max_weight <= NEW.min_weight THEN\n        RAISE EXCEPTION 'Le poids maximum doit être supérieur au poids minimum (min: %)', NEW.min_weight;\n    END IF;\n\n    -- Vérification du prix par kg\n    IF NEW.price_per_kg <= 0 THEN\n        RAISE EXCEPTION 'Le prix par kg doit être positif';\n    END IF;\n\n    -- Vérification du chevauchement des plages\n    IF EXISTS (\n        SELECT 1 \n        FROM weight_based_pricing w\n        WHERE w.service_type_id = NEW.service_type_id\n        AND w.id != NEW.id\n        AND (\n            (NEW.min_weight BETWEEN w.min_weight AND w.max_weight)\n            OR (NEW.max_weight BETWEEN w.min_weight AND w.max_weight)\n        )\n    ) THEN\n        RAISE EXCEPTION 'Chevauchement détecté avec une plage existante';\n    END IF;\n\n    -- Mise à jour du timestamp\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    \n    RAISE NOTICE 'Validation réussie pour la plage: % - %kg', NEW.min_weight, NEW.max_weight;\n    RETURN NEW;\nEND;\n$function$\n"
}]




