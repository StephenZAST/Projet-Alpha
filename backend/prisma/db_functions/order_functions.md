[
  {
    "procedure_name": "create_order_with_items",
    "procedure_definition": "CREATE OR REPLACE FUNCTION public.create_order_with_items(p_userid uuid, p_serviceid uuid, p_addressid uuid, p_isrecurring boolean, p_recurrencetype recurrence_type, p_collectiondate timestamp with time zone, p_deliverydate timestamp with time zone, p_affiliatecode text, p_service_type_id uuid, p_paymentmethod payment_method_enum, p_items order_item_input[])\n RETURNS TABLE(id uuid, \"userId\" uuid, \"serviceId\" uuid, \"addressId\" uuid, \"totalAmount\" numeric, status order_status, items json)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_order_id UUID;\r\n    v_total_amount NUMERIC := 0;\r\n    v_item order_item_input;\r\n    v_article_price NUMERIC;\r\n    v_items_json JSON := '[]'::JSON;\r\nBEGIN\r\n    -- 1. Créer la commande\r\n    INSERT INTO orders (\r\n        \"userId\",\r\n        \"serviceId\",\r\n        \"addressId\",\r\n        \"isRecurring\",\r\n        \"recurrenceType\",\r\n        \"collectionDate\",\r\n        \"deliveryDate\",\r\n        \"affiliateCode\",\r\n        service_type_id,\r\n        \"paymentMethod\",\r\n        status,\r\n        \"totalAmount\",\r\n        \"createdAt\",\r\n        \"updatedAt\"\r\n    )\r\n    VALUES (\r\n        p_userId,\r\n        p_serviceId,\r\n        p_addressId,\r\n        p_isRecurring,\r\n        p_recurrenceType,\r\n        p_collectionDate,\r\n        p_deliveryDate,\r\n        p_affiliateCode,\r\n        p_service_type_id,\r\n        p_paymentMethod,\r\n        'PENDING',\r\n        0,\r\n        CURRENT_TIMESTAMP,\r\n        CURRENT_TIMESTAMP\r\n    )\r\n    RETURNING id INTO v_order_id;\r\n\r\n    -- 2. Créer les items et calculer le total\r\n    FOREACH v_item IN ARRAY p_items\r\n    LOOP\r\n        -- Récupérer le prix de l'article\r\n        SELECT \r\n            CASE \r\n                WHEN v_item.\"isPremium\" THEN \"premiumPrice\" \r\n                ELSE \"basePrice\" \r\n            END INTO v_article_price\r\n        FROM articles\r\n        WHERE id = v_item.\"articleId\";\r\n\r\n        -- Insérer l'item\r\n        INSERT INTO order_items (\r\n            \"orderId\",\r\n            \"articleId\",\r\n            \"serviceId\",\r\n            quantity,\r\n            \"unitPrice\",\r\n            \"createdAt\",\r\n            \"updatedAt\"\r\n        )\r\n        VALUES (\r\n            v_order_id,\r\n            v_item.\"articleId\",\r\n            p_serviceId,\r\n            v_item.quantity,\r\n            v_article_price,\r\n            CURRENT_TIMESTAMP,\r\n            CURRENT_TIMESTAMP\r\n        );\r\n\r\n        -- Ajouter à la somme totale\r\n        v_total_amount := v_total_amount + (v_article_price * v_item.quantity);\r\n\r\n        -- Construire le JSON des items\r\n        SELECT json_agg(row_to_json(i))\r\n        FROM (\r\n            SELECT i.*, \r\n                   a.name as article_name, \r\n                   a.description as article_description,\r\n                   ac.name as category_name\r\n            FROM order_items i\r\n            JOIN articles a ON i.\"articleId\" = a.id\r\n            LEFT JOIN article_categories ac ON a.\"categoryId\" = ac.id\r\n            WHERE i.\"orderId\" = v_order_id\r\n        ) i INTO v_items_json;\r\n    END LOOP;\r\n\r\n    -- 3. Mettre à jour le montant total de la commande\r\n    UPDATE orders\r\n    SET \"totalAmount\" = v_total_amount\r\n    WHERE id = v_order_id;\r\n\r\n    -- 4. Retourner le résultat\r\n    RETURN QUERY\r\n    SELECT \r\n        o.id,\r\n        o.\"userId\",\r\n        o.\"serviceId\",\r\n        o.\"addressId\",\r\n        o.\"totalAmount\",\r\n        o.status,\r\n        v_items_json::JSON as items\r\n    FROM orders o\r\n    WHERE o.id = v_order_id;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "procedure_name": "create_flash_order",
    "procedure_definition": "CREATE OR REPLACE FUNCTION public.create_flash_order(order_data jsonb, note_text text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE \r\n    created_order jsonb;\r\n    new_order_id uuid;\r\nBEGIN\r\n    -- 1. Insérer la commande avec le statut DRAFT\r\n    INSERT INTO orders (\r\n        \"userId\",\r\n        \"addressId\",\r\n        status,\r\n        \"totalAmount\",\r\n        \"createdAt\",\r\n        \"updatedAt\"\r\n    )\r\n    VALUES (\r\n        (order_data->>'userId')::uuid,\r\n        (order_data->>'addressId')::uuid,\r\n        'DRAFT'::order_status,\r\n        COALESCE((order_data->>'totalAmount')::numeric, 0),\r\n        CURRENT_TIMESTAMP,\r\n        CURRENT_TIMESTAMP\r\n    )\r\n    RETURNING id INTO new_order_id;\r\n\r\n    -- 2. Insérer la note seulement si elle contient du texte\r\n    IF note_text IS NOT NULL AND trim(note_text) != '' THEN\r\n        INSERT INTO order_notes (\r\n            order_id, \r\n            note, \r\n            created_at, \r\n            updated_at\r\n        )\r\n        VALUES (\r\n            new_order_id, \r\n            note_text, \r\n            CURRENT_TIMESTAMP, \r\n            CURRENT_TIMESTAMP\r\n        );\r\n    END IF;\r\n\r\n    -- 3. Récupérer la commande avec toutes ses relations\r\n    SELECT jsonb_build_object(\r\n        'id', o.id,\r\n        'userId', o.\"userId\",\r\n        'addressId', o.\"addressId\",\r\n        'status', o.status,\r\n        'totalAmount', o.\"totalAmount\",\r\n        'createdAt', o.\"createdAt\",\r\n        'updatedAt', o.\"updatedAt\",\r\n        'note', COALESCE(n.note, ''),\r\n        'address', CASE WHEN a.id IS NOT NULL THEN\r\n            jsonb_build_object(\r\n                'id', a.id,\r\n                'street', a.street,\r\n                'city', a.city,\r\n                'postal_code', a.postal_code,\r\n                'gps_latitude', a.gps_latitude,\r\n                'gps_longitude', a.gps_longitude,\r\n                'is_default', a.is_default\r\n            )\r\n        ELSE NULL END,\r\n        'user', CASE WHEN u.id IS NOT NULL THEN\r\n            jsonb_build_object(\r\n                'id', u.id,\r\n                'firstName', u.first_name,\r\n                'lastName', u.last_name,\r\n                'email', u.email,\r\n                'phone', u.phone\r\n            )\r\n        ELSE NULL END\r\n    ) INTO created_order\r\n    FROM orders o\r\n    LEFT JOIN (\r\n        SELECT on2.order_id, on2.note\r\n        FROM order_notes on2\r\n        WHERE on2.order_id = new_order_id\r\n    ) n ON true\r\n    LEFT JOIN addresses a ON a.id = o.\"addressId\"\r\n    LEFT JOIN users u ON u.id = o.\"userId\"\r\n    WHERE o.id = new_order_id;\r\n\r\n    RETURN created_order;\r\nEND;\r\n$function$\n"
  },
  {
    "procedure_name": "complete_flash_order",
    "procedure_definition": "CREATE OR REPLACE FUNCTION public.complete_flash_order(p_order_id uuid, p_service_id uuid, p_items json[], p_collection_date timestamp without time zone DEFAULT NULL::timestamp without time zone, p_delivery_date timestamp without time zone DEFAULT NULL::timestamp without time zone)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_order orders%ROWTYPE;\r\n  v_total DECIMAL := 0;\r\n  v_result JSON;\r\nBEGIN\r\n  -- 1. Récupérer et vérifier la commande\r\n  SELECT * INTO v_order\r\n  FROM orders \r\n  WHERE id = p_order_id AND status = 'DRAFT'\r\n  FOR UPDATE;\r\n\r\n  IF NOT FOUND THEN\r\n    RAISE EXCEPTION 'Commande flash non trouvée ou non modifiable';\r\n  END IF;\r\n\r\n  -- 2. Mettre à jour la commande\r\n  UPDATE orders SET\r\n    \"serviceId\" = p_service_id,\r\n    status = 'PENDING',\r\n    \"collectionDate\" = p_collection_date,\r\n    \"deliveryDate\" = p_delivery_date,\r\n    \"updatedAt\" = NOW()\r\n  WHERE id = p_order_id\r\n  RETURNING * INTO v_order;\r\n\r\n  -- 3. Insérer les articles et calculer le total\r\n  WITH inserted_items AS (\r\n    INSERT INTO order_items (\r\n      \"orderId\",\r\n      \"articleId\",\r\n      \"serviceId\",\r\n      quantity,\r\n      \"unitPrice\",\r\n      \"createdAt\",\r\n      \"updatedAt\"\r\n    )\r\n    SELECT \r\n      p_order_id,\r\n      (item->>'articleId')::UUID,\r\n      p_service_id,\r\n      (item->>'quantity')::INT,\r\n      (item->>'unitPrice')::DECIMAL,\r\n      NOW(),\r\n      NOW()\r\n    FROM json_array_elements(array_to_json(p_items)::JSON) AS item\r\n    RETURNING *\r\n  )\r\n  SELECT SUM(quantity * \"unitPrice\") INTO v_total FROM inserted_items;\r\n\r\n  -- 4. Mettre à jour le total\r\n  UPDATE orders \r\n  SET \"totalAmount\" = v_total\r\n  WHERE id = p_order_id;\r\n\r\n  -- 5. Construire le résultat JSON avec la structure exacte attendue\r\n  WITH order_details AS (\r\n    SELECT \r\n      o.*,\r\n      json_build_object(\r\n        'id', u.id,\r\n        'email', u.email,\r\n        'phone', u.phone,\r\n        'lastName', u.last_name,\r\n        'firstName', u.first_name\r\n      ) as user_info,\r\n      json_build_object(\r\n        'id', a.id,\r\n        'city', a.city,\r\n        'street', a.street,\r\n        'is_default', a.is_default,\r\n        'postal_code', a.postal_code,\r\n        'gps_latitude', a.gps_latitude,\r\n        'gps_longitude', a.gps_longitude\r\n      ) as address_info,\r\n      COALESCE(json_agg(\r\n        json_build_object(\r\n          'id', i.id,\r\n          'orderId', i.\"orderId\",\r\n          'articleId', i.\"articleId\",\r\n          'quantity', i.quantity,\r\n          'unitPrice', i.\"unitPrice\"\r\n        )\r\n      ) FILTER (WHERE i.id IS NOT NULL), '[]'::json) as items_info\r\n    FROM orders o\r\n    LEFT JOIN users u ON u.id = o.\"userId\"\r\n    LEFT JOIN addresses a ON a.id = o.\"addressId\"\r\n    LEFT JOIN order_items i ON i.\"orderId\" = o.id\r\n    WHERE o.id = p_order_id\r\n    GROUP BY o.id, u.id, a.id\r\n  )\r\n  SELECT json_build_object(\r\n    'data', json_build_object(\r\n      'order', json_build_object(\r\n        'id', od.id,\r\n        'status', od.status,\r\n        'userId', od.\"userId\",\r\n        'serviceId', od.\"serviceId\",\r\n        'addressId', od.\"addressId\",\r\n        'totalAmount', od.\"totalAmount\",\r\n        'createdAt', od.\"createdAt\",\r\n        'updatedAt', od.\"updatedAt\",\r\n        'user', od.user_info,\r\n        'address', od.address_info,\r\n        'items', od.items_info\r\n      )\r\n    )\r\n  ) INTO v_result\r\n  FROM order_details od;\r\n\r\n  RETURN v_result;\r\nEND;\r\n$function$\n"
  },
  {
    "procedure_name": "archive_completed_orders",
    "procedure_definition": "CREATE OR REPLACE FUNCTION public.archive_completed_orders()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    IF NEW.status = 'DELIVERED' AND OLD.status != 'DELIVERED' THEN\r\n        INSERT INTO orders_archive \r\n        SELECT \r\n            OLD.*,\r\n            CURRENT_TIMESTAMP\r\n        FROM orders \r\n        WHERE id = OLD.id;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "procedure_name": "cleanup_old_orders",
    "procedure_definition": "CREATE OR REPLACE FUNCTION public.cleanup_old_orders(days_threshold integer DEFAULT 30)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    archived_count INTEGER;\r\nBEGIN\r\n    -- Archive old completed orders\r\n    WITH orders_to_archive AS (\r\n        DELETE FROM orders \r\n        WHERE status = 'DELIVERED'\r\n        AND \"createdAt\" < NOW() - (days_threshold * INTERVAL '1 day')\r\n        RETURNING *\r\n    )\r\n    INSERT INTO orders_archive \r\n    SELECT \r\n        t.*,\r\n        NOW() as archived_at\r\n    FROM orders_to_archive t;\r\n\r\n    GET DIAGNOSTICS archived_count = ROW_COUNT;\r\n    RETURN archived_count;\r\nEND;\r\n$function$\n"
  },
  {
    "procedure_name": "maintain_orders_archive",
    "procedure_definition": "CREATE OR REPLACE PROCEDURE public.maintain_orders_archive()\n LANGUAGE plpgsql\nAS $procedure$\r\nDECLARE\r\n    archived INTEGER;\r\nBEGIN\r\n    -- Archive orders older than 30 days\r\n    SELECT cleanup_old_orders(30) INTO archived;\r\n    \r\n    RAISE NOTICE 'Archived % old completed orders', archived;\r\nEND;\r\n$procedure$\n"
  }
]