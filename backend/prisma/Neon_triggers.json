{
  "documentation": {
    "introduction": "Ce document détaille les triggers de la base de données de l'application. Les triggers sont des procédures stockées qui sont automatiquement exécutées en réponse à certains événements sur des tables spécifiques. Ils permettent d'appliquer des règles métier, de maintenir l'intégrité des données et d'automatiser certaines tâches. L'objectif est de fournir une vue d'ensemble complète de leur fonctionnement interne.",
    "categories": {
      "loyalty": {
        "description": "Triggers liés à la gestion du système de fidélité, incluant la création de points de fidélité, la validation des transactions et la mise à jour des soldes.",
        "triggers": [
          {
            "name": "create_user_loyalty_points",
            "description": "Ce trigger est exécuté après l'insertion d'un nouvel utilisateur dans la table `users`. Il initialise automatiquement les points de fidélité pour ce nouvel utilisateur en insérant un enregistrement dans la table `loyalty_points` avec un solde initial de 0.",
            "table": "users",
            "function": "initialize_user_loyalty_points",
            "timing": "AFTER INSERT",
            "definition": "CREATE OR REPLACE FUNCTION public.initialize_user_loyalty_points()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n INSERT INTO loyalty_points (\r\n id,\r\n user_id,\r\n \"pointsBalance\",\r\n \"totalEarned\",\r\n \"createdAt\",\r\n \"updatedAt\"\r\n )\r\n VALUES (\r\n gen_random_uuid(),\r\n NEW.id,\r\n 0,\r\n 0,\r\n CURRENT_TIMESTAMP,\r\n CURRENT_TIMESTAMP\r\n );\r\n RETURN NEW;\r\nEND;\r\n$function$\n",
            "details": "Ce trigger garantit que chaque nouvel utilisateur dispose d'un enregistrement initial de points de fidélité. L'utilisation de `gen_random_uuid()` assure un identifiant unique pour chaque enregistrement `loyalty_points`. L'exécution est implicitement AFTER INSERT en l'absence de specification du moment."
          },
          {
            "name": "ensure_valid_loyalty_points",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `loyalty_points`. Il valide que le solde de points et le total des points gagnés ne sont pas négatifs et que le solde actuel ne dépasse pas le total des points gagnés. Il met également à jour le timestamp `updatedAt`.",
            "table": "loyalty_points",
            "function": "validate_loyalty_points_constraint",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.validate_loyalty_points_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n -- Vérification du solde de points positif\n IF NEW.\"pointsBalance\" < 0 THEN\n RAISE EXCEPTION 'Le solde de points ne peut pas être négatif';\n END IF;\n\n -- Vérification du total des points gagnés\n IF NEW.\"totalEarned\" < 0 THEN\n RAISE EXCEPTION 'Le total des points gagnés ne peut pas être négatif';\n END IF;\n\n -- Vérification de la cohérence\n IF NEW.\"pointsBalance\" > NEW.\"totalEarned\" THEN\n RAISE EXCEPTION 'Le solde actuel ne peut pas dépasser le total des points gagnés';\n END IF;\n\n -- Mise à jour automatique du timestamp en camelCase\n NEW.\"updatedAt\" = CURRENT_TIMESTAMP;\n \n RETURN NEW;\nEND;\n$function$\n",
            "details": "Ce trigger assure l'intégrité des données dans la table `loyalty_points` en empêchant des valeurs incohérentes. Il utilise `RAISE EXCEPTION` pour interrompre l'opération et signaler une erreur si une validation échoue. L'exécution est BEFORE INSERT OR UPDATE."
          },
          {
            "name": "update_loyalty_points_timestamp",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `loyalty_points`. Il met à jour le timestamp `updatedAt` à la valeur courante.",
            "table": "loyalty_points",
            "function": "update_loyalty_points_timestamp",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.update_loyalty_points_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n NEW.\"updatedAt\" = CURRENT_TIMESTAMP;\n RETURN NEW;\nEND;\n$function$\n",
            "details": "Ce trigger garantit que la colonne `updatedAt` est toujours à jour lors de toute modification des données dans la table `loyalty_points`. L'exécution est BEFORE INSERT OR UPDATE."
          }
        ]
      },
      "orders": {
        "description": "Triggers liés à la gestion des commandes, incluant la validation des informations de commande, le calcul des totaux et la mise à jour des timestamps.",
        "triggers": [
          {
            "name": "ensure_valid_order_items",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `order_items`. Il valide que la quantité et le prix unitaire sont supérieurs à zéro, que le poids est positif si applicable, et calcule automatiquement le total. Il met également à jour le timestamp `updated_at`.",
            "table": "order_items",
            "function": "validate_order_items_constraint",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.validate_order_items_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n -- Vérification de la quantité\n IF NEW.quantity <= 0 THEN\n RAISE EXCEPTION 'La quantité doit être supérieure à zéro';\n END IF;\n\n -- Vérification du prix unitaire\n IF NEW.\"unitPrice\" <= 0 THEN\n RAISE EXCEPTION 'Le prix unitaire doit être supérieur à zéro';\n END IF;\n\n -- Vérification du poids si applicable\n IF NEW.weight IS NOT NULL AND NEW.weight <= 0 THEN\n RAISE EXCEPTION 'Le poids doit être supérieur à zéro';\n END IF;\n\n -- Calcul automatique du total\n NEW.total = NEW.quantity * NEW.\"unitPrice\";\n \n -- Mise à jour du timestamp\n NEW.updated_at = CURRENT_TIMESTAMP;\n\n RETURN NEW;\nEND;\n$function$\n",
            "details": "Ce trigger assure l'intégrité des données dans la table `order_items` en validant les valeurs et en calculant automatiquement le total. L'exécution est BEFORE INSERT OR UPDATE."
          },
          {
            "name": "flash_order_note",
            "description": "Ce trigger est exécuté après l'insertion d'une nouvelle commande dans la table `orders`. Il insère automatiquement une note dans la table `order_notes` indiquant qu'une commande flash a été créée.",
            "table": "orders",
            "function": "insert_flash_order_note",
            "timing": "AFTER INSERT",
            "definition": "CREATE OR REPLACE FUNCTION public.insert_flash_order_note()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n INSERT INTO order_notes (\n order_id,\n note,\n created_at,\n updated_at\n ) VALUES (\n NEW.id,\n 'Commande flash créée',\n CURRENT_TIMESTAMP,\n CURRENT_TIMESTAMP\n );\n RETURN NEW;\nEND;\n$function$\n",
            "details": "Ce trigger automatise la création d'une note standard pour chaque commande flash.  L'exécution est implicitement AFTER INSERT en l'absence de specification du moment."
          },
          {
            "name": "order_items_total_update",
            "description": "Ce trigger est exécuté après toute insertion ou mise à jour d'un enregistrement dans la table `order_items`. Il met à jour le total de la commande correspondante dans la table `orders` en utilisant la fonction `calculate_order_total` et met à jour le timestamp `updated_at` de la commande.",
            "table": "order_items",
            "function": "update_order_total",
            "timing": "AFTER INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.update_order_total()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n UPDATE orders\r\n SET total = calculate_order_total(NEW.\"orderId\"),\r\n updated_at = CURRENT_TIMESTAMP\r\n WHERE id = NEW.\"orderId\";\r\n RETURN NEW;\r\nEND;\r\n$function$\n",
            "details": "Ce trigger assure que le total de la commande est toujours à jour en fonction des éléments de commande. L'exécution est AFTER INSERT OR UPDATE.  La fonction `calculate_order_total` doit être définie ailleurs et calcule le total de la commande en fonction de ses éléments."
          },
          {
            "name": "order_metadata_timestamp",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `order_metadata`. Il met à jour les timestamps `created_at` et `updated_at` en fonction de l'opération (INSERT ou UPDATE).",
            "table": "order_metadata",
            "function": "update_timestamp",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.update_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n IF TG_OP = 'UPDATE' THEN\r\n NEW.updated_at = CURRENT_TIMESTAMP;\r\n ELSE\r\n -- Pour INSERT\r\n NEW.created_at = COALESCE(NEW.created_at, CURRENT_TIMESTAMP);\r\n NEW.updated_at = CURRENT_TIMESTAMP;\r\n END IF;\r\n RETURN NEW;\r\nEND;\r\n$function$\n",
            "details": "Ce trigger assure que les timestamps sont correctement mis à jour lors de toute modification des données dans la table `order_metadata`. L'exécution est BEFORE INSERT OR UPDATE."
          },
          {
            "name": "order_note_sync_trigger",
            "description": "Ce trigger est exécuté après toute insertion ou mise à jour d'une note de commande dans la table `order_notes`.  Il met à jour le timestamp `updated_at` de la commande correspondante dans la table `orders` si une nouvelle note est insérée ou si une note existante est modifiée.",
            "table": "order_notes",
            "function": "sync_order_note",
            "timing": "AFTER INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.sync_order_note()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n IF TG_OP = 'INSERT' THEN\n UPDATE orders \n SET updated_at = CURRENT_TIMESTAMP\n WHERE id = NEW.order_id;\n ELSIF TG_OP = 'UPDATE' THEN\n IF OLD.note <> NEW.note THEN\n UPDATE orders \n SET updated_at = CURRENT_TIMESTAMP\n WHERE id = NEW.order_id;\n END IF;\n END IF;\n RETURN NEW;\nEND;\n$function$\n",
            "details": "Ce trigger assure que la table `orders` est mise à jour lors de la création ou modification des notes de commandes. L'exécution est implicitement AFTER INSERT OR UPDATE en l'absence de specification du moment."
          },
          {
            "name": "order_weights_timestamp",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `order_weights`. Il met à jour le timestamp `updated_at` à la valeur courante.",
            "table": "order_weights",
            "function": "update_updated_at_column",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n NEW.updated_at = CURRENT_TIMESTAMP;\r\n RETURN NEW;\r\nEND;\r\n$function$\n",
            "details": "Ce trigger garantit que la colonne `updated_at` est toujours à jour lors de toute modification des données dans la table `order_weights`. L'exécution est BEFORE INSERT OR UPDATE."
          },
          {
            "name": "update_orders_updated_at",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `orders`. Il met à jour le timestamp `updated_at` à la valeur courante.",
            "table": "orders",
            "function": "update_orders_timestamp",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.update_orders_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n NEW.updated_at = CURRENT_TIMESTAMP;\n RETURN NEW;\nEND;\n$function$\n",
            "details": "Ce trigger garantit que la colonne `updated_at` est toujours à jour lors de toute modification des données dans la table `orders`. L'exécution est BEFORE INSERT OR UPDATE."
          }
        ]
      },
      "other": {
        "description": "Triggers divers qui ne rentrent pas dans les autres catégories, incluant la gestion des affiliations, les transactions de points, la validation des plages de poids, et la mise à jour des timestamps.",
        "triggers": [
          {
            "name": "after_affiliate_earnings_update",
            "description": "Ce trigger est exécuté après toute mise à jour d'un enregistrement dans la table `affiliate_profiles`. Il met à jour le niveau d'affiliation en fonction du total des gains de l'affilié.",
            "table": "affiliate_profiles",
            "function": "trigger_update_affiliate_level",
            "timing": "AFTER UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.trigger_update_affiliate_level()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n -- Mise à jour du niveau basé sur les gains\n UPDATE affiliate_profiles\n SET level_id = (\n SELECT id \n FROM affiliate_levels \n WHERE minimum_earnings <= NEW.total_earned \n ORDER BY minimum_earnings DESC \n LIMIT 1\n )\n WHERE id = NEW.id;\n \n NEW.updated_at = CURRENT_TIMESTAMP;\n RETURN NEW;\nEND;\n$function$\n",
            "details": "Ce trigger automatise la mise à jour du niveau d'affiliation en fonction des gains de l'affilié. L'exécution est AFTER UPDATE."
          },
          {
            "name": "after_point_transaction",
            "description": "Ce trigger est exécuté après toute insertion d'une transaction de points dans la table `point_transactions`. Il met à jour le solde de points de l'utilisateur correspondant dans la table `loyalty_points` et vérifie que le nouveau solde n'est pas négatif.",
            "table": "point_transactions",
            "function": "update_loyalty_points_balance",
            "timing": "AFTER INSERT",
            "definition": "CREATE OR REPLACE FUNCTION public.update_loyalty_points_balance()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n -- Mise à jour du solde de points\n UPDATE loyalty_points\n SET \"pointsBalance\" = \"pointsBalance\" + NEW.amount,\n updated_at = CURRENT_TIMESTAMP\n WHERE \"userId\" = NEW.\"userId\";\n\n -- Vérification du nouveau solde\n IF EXISTS (\n SELECT 1 \n FROM loyalty_points \n WHERE \"userId\" = NEW.\"userId\" \n AND \"pointsBalance\" < 0\n ) THEN\n RAISE EXCEPTION 'Le solde de points ne peut pas être négatif';\n END IF;\n \n RETURN NEW;\nEND;\n$function$\n",
            "details": "Ce trigger assure la mise à jour du solde de points après chaque transaction et vérifie l'intégrité des données. L'exécution est implicitement AFTER INSERT en l'absence de specification du moment."
          },
          {
            "name": "ensure_valid_weight_range",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `weight_based_pricing`. Il valide que les valeurs minimales et maximales des poids sont correctes, que le prix par kg est positif, et qu'il n'y a pas de chevauchement avec d'autres plages de poids existantes. Il met également à jour le timestamp `updated_at`.",
            "table": "weight_based_pricing",
            "function": "validate_weight_range_constraint",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.validate_weight_range_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n -- Log de début de validation\n RAISE NOTICE 'Validation des plages de poids pour ID: %', NEW.id;\n\n -- Vérification des valeurs minimales\n IF NEW.min_weight IS NULL OR NEW.min_weight < 0 THEN\n RAISE EXCEPTION 'Le poids minimum doit être positif';\n END IF;\n\n -- Vérification des valeurs maximales\n IF NEW.max_weight IS NULL OR NEW.max_weight <= NEW.min_weight THEN\n RAISE EXCEPTION 'Le poids maximum doit être supérieur au poids minimum (min: %)', NEW.min_weight;\n END IF;\n\n -- Vérification du prix par kg\n IF NEW.price_per_kg <= 0 THEN\n RAISE EXCEPTION 'Le prix par kg doit être positif';\n END IF;\n\n -- Vérification du chevauchement des plages\n IF EXISTS (\n SELECT 1 \n FROM weight_based_pricing w\n WHERE w.service_type_id = NEW.service_type_id\n AND w.id != NEW.id\n AND (\n (NEW.min_weight BETWEEN w.min_weight AND w.max_weight)\n OR (NEW.max_weight BETWEEN w.min_weight AND w.max_weight)\n )\n ) THEN\n RAISE EXCEPTION 'Chevauchement détecté avec une plage existante';\n END IF;\n\n -- Mise à jour du timestamp\n NEW.updated_at = CURRENT_TIMESTAMP;\n \n RAISE NOTICE 'Validation réussie pour la plage: % - %kg', NEW.min_weight, NEW.max_weight;\n RETURN NEW;\nEND;\n$function$\n",
            "details": "Ce trigger assure l'intégrité des données dans la table `weight_based_pricing` en validant les valeurs et en empêchant les chevauchements de plages. L'exécution est BEFORE INSERT OR UPDATE. Il inclut des messages `RAISE NOTICE` pour faciliter le débogage."
          },
          {
            "name": "set_timestamp",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `reset_codes`. Il met à jour le timestamp `updated_at` à la valeur courante.",
            "table": "reset_codes",
            "function": "trigger_set_timestamp",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.trigger_set_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n NEW.updated_at = NOW();\n RETURN NEW;\nEND;\n$function$\n",
            "details": "Ce trigger garantit que la colonne `updated_at` est toujours à jour lors de toute modification des données dans la table `reset_codes`. L'exécution est BEFORE INSERT OR UPDATE. Utilise `NOW()` pour obtenir le timestamp courant."
          },
          {
            "name": "update_articles_timestamp",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `articles`. Il met à jour le timestamp `updated_at` à la valeur courante.",
            "table": "articles",
            "function": "update_timestamp_column",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.update_timestamp_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n NEW.updated_at = CURRENT_TIMESTAMP;\n RETURN NEW;\nEND;\n$function$\n",
            "details": "Ce trigger garantit que la colonne `updated_at` est toujours à jour lors de toute modification des données dans la table `articles`. L'exécution est BEFORE INSERT OR UPDATE."
          },
          {
            "name": "update_offer_subscriptions_timestamp",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `offer_subscriptions`. Il met à jour le timestamp `updated_at` à la valeur courante.",
            "table": "offer_subscriptions",
            "function": "update_updated_at_column",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n NEW.updated_at = CURRENT_TIMESTAMP;\r\n RETURN NEW;\r\nEND;\r\n$function$\n",
            "details": "Ce trigger garantit que la colonne `updated_at` est toujours à jour lors de toute modification des données dans la table `offer_subscriptions`. L'exécution est BEFORE INSERT OR UPDATE."
          },
          {
            "name": "update_offers_timestamp",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `offers`. Il met à jour le timestamp `updated_at` à la valeur courante.",
            "table": "offers",
            "function": "update_updated_at_column",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n NEW.updated_at = CURRENT_TIMESTAMP;\r\n RETURN NEW;\r\nEND;\r\n$function$\n",
            "details": "Ce trigger garantit que la colonne `updated_at` est toujours à jour lors de toute modification des données dans la table `offers`. L'exécution est BEFORE INSERT OR UPDATE."
          },
          {
            "name": "update_subscription_plans_timestamp",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `subscription_plans`. Il met à jour le timestamp `updated_at` à la valeur courante.",
            "table": "subscription_plans",
            "function": "update_updated_at_column",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n NEW.updated_at = CURRENT_TIMESTAMP;\r\n RETURN NEW;\r\nEND;\r\n$function$\n",
            "details": "Ce trigger garantit que la colonne `updated_at` est toujours à jour lors de toute modification des données dans la table `subscription_plans`. L'exécution est BEFORE INSERT OR UPDATE."
          }
        ]
      },
      "services": {
        "description": "Triggers liés à la gestion des services, incluant la validation des types de services et la mise à jour des timestamps.",
        "triggers": [
          {
            "name": "ensure_valid_service_type",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `service_types`. Il valide que le type de tarification (`pricing_type`) est l'une des valeurs autorisées ('FIXED', 'WEIGHT_BASED', 'CUSTOM').",
            "table": "service_types",
            "function": "validate_service_types_constraint",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.validate_service_types_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n IF NEW.pricing_type NOT IN ('FIXED', 'WEIGHT_BASED', 'CUSTOM') THEN\r\n RAISE NOTICE 'Invalid pricing_type: %', NEW.pricing_type;\r\n RAISE EXCEPTION 'Invalid pricing type. Must be FIXED, WEIGHT_BASED, or CUSTOM';\r\n END IF;\r\n RETURN NEW;\r\nEND;\r\n$function$\n",
            "details": "Ce trigger assure l'intégrité des données dans la table `service_types` en validant le type de tarification. L'exécution est BEFORE INSERT OR UPDATE. Il inclut un message `RAISE NOTICE` pour faciliter le débogage."
          },
          {
            "name": "update_article_service_compatibility_timestamp",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `article_service_compatibility`. Il met à jour le timestamp `updated_at` à la valeur courante.",
            "table": "article_service_compatibility",
            "function": "update_service_timestamps",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.update_service_timestamps()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n NEW.updated_at = CURRENT_TIMESTAMP;\r\n RETURN NEW;\r\nEND;\r\n$function$\n",
            "details": "Ce trigger garantit que la colonne `updated_at` est toujours à jour lors de toute modification des données dans la table `article_service_compatibility`. L'exécution est BEFORE INSERT OR UPDATE."
          },
          {
            "name": "update_service_types_timestamp",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `service_types`. Il met à jour les timestamps `created_at` et `updated_at` en fonction de l'opération (INSERT ou UPDATE).",
            "table": "service_types",
            "function": "update_timestamp",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.update_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n IF TG_OP = 'UPDATE' THEN\r\n NEW.updated_at = CURRENT_TIMESTAMP;\r\n ELSE\r\n -- Pour INSERT\r\n NEW.created_at = COALESCE(NEW.created_at, CURRENT_TIMESTAMP);\r\n NEW.updated_at = CURRENT_TIMESTAMP;\r\n END IF;\r\n RETURN NEW;\r\nEND;\r\n$function$\n",
            "details": "Ce trigger assure que les timestamps sont correctement mis à jour lors de toute modification des données dans la table `service_types`. L'exécution est BEFORE INSERT OR UPDATE."
          },
          {
            "name": "validate_article_service_price_trigger",
            "description": "Ce trigger est exécuté avant toute insertion ou mise à jour d'un enregistrement dans la table `article_service_prices`. Il valide le prix de base et le prix premium (si applicable), et assure que le prix au kilo est renseigné pour les services de type `WEIGHT_BASED`. Il met également à jour le timestamp `updated_at`.",
            "table": "article_service_prices",
            "function": "validate_article_service_price",
            "timing": "BEFORE INSERT OR UPDATE",
            "definition": "CREATE OR REPLACE FUNCTION public.validate_article_service_price()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n -- Validation du prix de base\n IF NEW.base_price < 0 THEN\n RAISE EXCEPTION 'Le prix de base ne peut pas être négatif';\n END IF;\n\n -- Validation du prix premium\n IF NEW.premium_price IS NOT NULL AND NEW.premium_price < 0 THEN\n RAISE EXCEPTION 'Le prix premium ne peut pas être négatif';\n END IF;\n\n -- Validation du prix au kilo pour WEIGHT_BASED\n IF NEW.pricing_type = 'WEIGHT_BASED' AND NEW.price_per_kg IS NULL THEN\n RAISE EXCEPTION 'Prix au kilo requis pour le type WEIGHT_BASED';\n END IF;\n\n -- Mise à jour timestamp\n NEW.updated_at = CURRENT_TIMESTAMP;\n \n RETURN NEW;\nEND;\n$function$\n",
            "details": "Ce trigger assure l'intégrité des données dans la table `article_service_prices` en validant les prix et en assurant la cohérence avec le type de tarification. L'exécution est BEFORE INSERT OR UPDATE."
          }
        ]
      }
    }
  }
}
