[{
  "proname": "uuid_nil",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.uuid_nil()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_nil$function$\n"
}, {
  "proname": "uuid_ns_dns",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.uuid_ns_dns()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$\n"
}, {
  "proname": "uuid_ns_url",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.uuid_ns_url()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_url$function$\n"
}, {
  "proname": "uuid_ns_oid",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.uuid_ns_oid()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$\n"
}, {
  "proname": "uuid_ns_x500",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.uuid_ns_x500()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$\n"
}, {
  "proname": "uuid_generate_v1",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.uuid_generate_v1()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$\n"
}, {
  "proname": "uuid_generate_v1mc",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.uuid_generate_v1mc()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$\n"
}, {
  "proname": "uuid_generate_v3",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.uuid_generate_v3(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$\n"
}, {
  "proname": "uuid_generate_v4",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.uuid_generate_v4()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$\n"
}, {
  "proname": "uuid_generate_v5",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.uuid_generate_v5(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$\n"
}, {
  "proname": "digest",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.digest(text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
}, {
  "proname": "digest",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.digest(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
}, {
  "proname": "hmac",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.hmac(text, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
}, {
  "proname": "hmac",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.hmac(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
}, {
  "proname": "crypt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.crypt(text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_crypt$function$\n"
}, {
  "proname": "gen_salt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.gen_salt(text)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt$function$\n"
}, {
  "proname": "gen_salt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.gen_salt(text, integer)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$\n"
}, {
  "proname": "encrypt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.encrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt$function$\n"
}, {
  "proname": "decrypt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.decrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt$function$\n"
}, {
  "proname": "encrypt_iv",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.encrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$\n"
}, {
  "proname": "decrypt_iv",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.decrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$\n"
}, {
  "proname": "gen_random_bytes",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.gen_random_bytes(integer)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_random_bytes$function$\n"
}, {
  "proname": "gen_random_uuid",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.gen_random_uuid()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/pgcrypto', $function$pg_random_uuid$function$\n"
}, {
  "proname": "pgp_sym_encrypt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_sym_encrypt(text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
}, {
  "proname": "pgp_sym_encrypt_bytea",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_sym_encrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
}, {
  "proname": "pgp_sym_encrypt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_sym_encrypt(text, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
}, {
  "proname": "pgp_sym_encrypt_bytea",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_sym_encrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
}, {
  "proname": "pgp_sym_decrypt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_sym_decrypt(bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
}, {
  "proname": "pgp_sym_decrypt_bytea",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_sym_decrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
}, {
  "proname": "pgp_sym_decrypt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_sym_decrypt(bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
}, {
  "proname": "pgp_sym_decrypt_bytea",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_sym_decrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
}, {
  "proname": "pgp_pub_encrypt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_pub_encrypt(text, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
}, {
  "proname": "pgp_pub_encrypt_bytea",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_pub_encrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
}, {
  "proname": "pgp_pub_encrypt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_pub_encrypt(text, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
}, {
  "proname": "pgp_pub_encrypt_bytea",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_pub_encrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
}, {
  "proname": "pgp_pub_decrypt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_pub_decrypt(bytea, bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
}, {
  "proname": "pgp_pub_decrypt_bytea",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_pub_decrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
}, {
  "proname": "pgp_pub_decrypt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_pub_decrypt(bytea, bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
}, {
  "proname": "pgp_pub_decrypt_bytea",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_pub_decrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
}, {
  "proname": "pgp_pub_decrypt",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_pub_decrypt(bytea, bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
}, {
  "proname": "pgp_pub_decrypt_bytea",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_pub_decrypt_bytea(bytea, bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
}, {
  "proname": "pgp_key_id",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_key_id(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_key_id_w$function$\n"
}, {
  "proname": "armor",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.armor(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
}, {
  "proname": "armor",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.armor(bytea, text[], text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
}, {
  "proname": "dearmor",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.dearmor(text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_dearmor$function$\n"
}, {
  "proname": "pgp_armor_headers",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.pgp_armor_headers(text, OUT key text, OUT value text)\n RETURNS SETOF record\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_armor_headers$function$\n"
}, {
  "proname": "update_loyalty_points_updated_at",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.update_loyalty_points_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "update_order_items_updated_at",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.update_order_items_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "log_change",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.log_change(message text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RAISE NOTICE '%', message;\r\nEND;\r\n$function$\n"
}, {
  "proname": "format_status",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.format_status(is_done boolean)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN CASE WHEN is_done THEN '✅' ELSE '❌' END;\nEND;\n$function$\n"
}, {
  "proname": "trigger_set_timestamp",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.trigger_set_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "update_timestamp_column",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.update_timestamp_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.\"updatedAt\" = CURRENT_TIMESTAMP;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "proname": "sync_order_note",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.sync_order_note()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    IF TG_OP = 'INSERT' THEN\n        UPDATE orders \n        SET updated_at = CURRENT_TIMESTAMP\n        WHERE id = NEW.order_id;\n    ELSIF TG_OP = 'UPDATE' THEN\n        IF OLD.note <> NEW.note THEN\n            UPDATE orders \n            SET updated_at = CURRENT_TIMESTAMP\n            WHERE id = NEW.order_id;\n        END IF;\n    END IF;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "get_table_structure",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.get_table_structure(table_name text)\n RETURNS TABLE(column_name text, data_type text, is_nullable boolean, column_default text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        c.column_name::text,\n        c.data_type::text,\n        c.is_nullable::boolean,\n        c.column_default::text\n    FROM information_schema.columns c\n    WHERE c.table_schema = 'public'\n    AND c.table_name = $1\n    ORDER BY c.ordinal_position;\nEND;\n$function$\n"
}, {
  "proname": "list_functions",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.list_functions()\n RETURNS TABLE(function_name text, return_type text, argument_types text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        p.proname::text,\n        pg_get_function_result(p.oid)::text,\n        pg_get_function_arguments(p.oid)::text\n    FROM pg_proc p\n    JOIN pg_namespace n ON p.pronamespace = n.oid\n    WHERE n.nspname = 'public';\nEND;\n$function$\n"
}, {
  "proname": "list_procedures",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.list_procedures()\n RETURNS TABLE(procedure_name text, argument_types text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        p.proname::text,\n        pg_get_function_arguments(p.oid)::text\n    FROM pg_proc p\n    JOIN pg_namespace n ON p.pronamespace = n.oid\n    WHERE n.nspname = 'public'\n    AND p.prokind = 'p';\nEND;\n$function$\n"
}, {
  "proname": "calculate_weight_price",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.calculate_weight_price(weight numeric, service_type_id uuid)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN (\n        SELECT price \n        FROM weight_based_pricing \n        WHERE min_weight <= weight \n        AND max_weight > weight \n        AND service_type_id = $2\n        LIMIT 1\n    );\nEND;\n$function$\n"
}, {
  "proname": "archive_article",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.archive_article(article_id_param uuid)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    INSERT INTO article_archives \n    SELECT *, CURRENT_TIMESTAMP as archived_at \n    FROM articles \n    WHERE id = article_id_param;\n    \n    DELETE FROM articles WHERE id = article_id_param;\n    RETURN FOUND;\nEND;\n$function$\n"
}, {
  "proname": "calculate_order_total",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.calculate_order_total(order_id_param uuid)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN COALESCE((\r\n        SELECT SUM(quantity * \"unitPrice\")\r\n        FROM order_items\r\n        WHERE \"orderId\" = order_id_param\r\n    ), 0);\r\nEND;\r\n$function$\n"
}, {
  "proname": "update_order_total",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.update_order_total()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    UPDATE orders\r\n    SET total = calculate_order_total(NEW.\"orderId\"),\r\n        updated_at = CURRENT_TIMESTAMP\r\n    WHERE id = NEW.\"orderId\";\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "proname": "list_triggers",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.list_triggers()\n RETURNS TABLE(trigger_name text, table_name text, event_type text, function_name text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        t.tgname::text,\n        c.relname::text,\n        CASE \n            WHEN t.tgtype & 2 > 0 THEN 'BEFORE'\n            WHEN t.tgtype & 16 > 0 THEN 'AFTER'\n            ELSE 'UNKNOWN'\n        END::text,\n        p.proname::text\n    FROM pg_trigger t\n    JOIN pg_class c ON t.tgrelid = c.oid\n    JOIN pg_proc p ON t.tgfoid = p.oid\n    WHERE c.relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public');\nEND;\n$function$\n"
}, {
  "proname": "calculate_service_price",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.calculate_service_price(article_id uuid, service_type_id uuid, weight numeric DEFAULT NULL::numeric)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    base_price numeric;\nBEGIN\n    -- Récupérer le prix spécifique à l'article et au service\n    SELECT price INTO base_price\n    FROM article_service_prices\n    WHERE article_id = $1 AND service_type_id = $2;\n\n    -- Si pas de prix spécifique et poids fourni, calculer basé sur le poids\n    IF base_price IS NULL AND weight IS NOT NULL THEN\n        base_price := calculate_weight_price(weight, service_type_id);\n    END IF;\n\n    RETURN base_price;\nEND;\n$function$\n"
}, {
  "proname": "trigger_update_affiliate_level",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.trigger_update_affiliate_level()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Mise à jour du niveau basé sur les gains\n    UPDATE affiliate_profiles\n    SET level_id = (\n        SELECT id \n        FROM affiliate_levels \n        WHERE minimum_earnings <= NEW.total_earned \n        ORDER BY minimum_earnings DESC \n        LIMIT 1\n    )\n    WHERE id = NEW.id;\n    \n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "increment_referral_count",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.increment_referral_count()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    IF NEW.referrer_id IS NOT NULL THEN\n        UPDATE users\n        SET referral_count = referral_count + 1\n        WHERE id = NEW.referrer_id;\n    END IF;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "reset_monthly_earnings",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.reset_monthly_earnings()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    UPDATE affiliate_profiles\n    SET monthly_earnings = 0,\n        updated_at = CURRENT_TIMESTAMP;\nEND;\n$function$\n"
}, {
  "proname": "initialize_default_pricing",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.initialize_default_pricing(article_id_param uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    INSERT INTO article_service_prices (\n        article_id, \n        service_type_id, \n        price, \n        created_at, \n        updated_at\n    )\n    SELECT \n        article_id_param,\n        st.id,\n        0,\n        CURRENT_TIMESTAMP,\n        CURRENT_TIMESTAMP\n    FROM service_types st\n    WHERE NOT EXISTS (\n        SELECT 1 FROM article_service_prices\n        WHERE article_id = article_id_param\n        AND service_type_id = st.id\n    );\nEND;\n$function$\n"
}, {
  "proname": "migrate_article_prices",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.migrate_article_prices()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    INSERT INTO article_service_prices (\n        article_id, \n        service_type_id, \n        price, \n        created_at, \n        updated_at\n    )\n    SELECT \n        a.id,\n        st.id,\n        a.price,\n        CURRENT_TIMESTAMP,\n        CURRENT_TIMESTAMP\n    FROM articles a\n    CROSS JOIN service_types st\n    WHERE NOT EXISTS (\n        SELECT 1 FROM article_service_prices asp\n        WHERE asp.article_id = a.id\n        AND asp.service_type_id = st.id\n    );\nEND;\n$function$\n"
}, {
  "proname": "update_article_services",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.update_article_services()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    UPDATE article_service_compatibility\n    SET updated_at = CURRENT_TIMESTAMP;\nEND;\n$function$\n"
}, {
  "proname": "update_article_services",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.update_article_services(article_id_param uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    UPDATE article_service_compatibility\n    SET updated_at = CURRENT_TIMESTAMP\n    WHERE article_id = article_id_param;\nEND;\n$function$\n"
}, {
  "proname": "update_loyalty_points_balance",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.update_loyalty_points_balance()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Mise à jour du solde de points\n    UPDATE loyalty_points\n    SET \"pointsBalance\" = \"pointsBalance\" + NEW.amount,\n        updated_at = CURRENT_TIMESTAMP\n    WHERE \"userId\" = NEW.\"userId\";\n\n    -- Vérification du nouveau solde\n    IF EXISTS (\n        SELECT 1 \n        FROM loyalty_points \n        WHERE \"userId\" = NEW.\"userId\" \n        AND \"pointsBalance\" < 0\n    ) THEN\n        RAISE EXCEPTION 'Le solde de points ne peut pas être négatif';\n    END IF;\n    \n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "create_flash_order",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.create_flash_order(order_data jsonb, note_text text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    new_order_id uuid;\n    created_order jsonb;\nBEGIN\n    -- Insérer la commande avec statut DRAFT\n    INSERT INTO orders (\n        \"userId\",\n        \"serviceId\",\n        \"addressId\",\n        status,\n        total,\n        created_at,\n        updated_at\n    )\n    SELECT \n        (order_data->>'userId')::uuid,\n        (order_data->>'serviceId')::uuid,\n        (order_data->>'addressId')::uuid,\n        'DRAFT',\n        0,\n        CURRENT_TIMESTAMP,\n        CURRENT_TIMESTAMP\n    RETURNING id INTO new_order_id;\n\n    -- Insérer la note si fournie\n    IF note_text IS NOT NULL THEN\n        INSERT INTO order_notes (\n            order_id,\n            note,\n            created_at,\n            updated_at\n        ) VALUES (\n            new_order_id,\n            note_text,\n            CURRENT_TIMESTAMP,\n            CURRENT_TIMESTAMP\n        );\n    END IF;\n\n    -- Récupérer la commande créée\n    SELECT jsonb_build_object(\n        'id', o.id,\n        'userId', o.\"userId\",\n        'serviceId', o.\"serviceId\",\n        'addressId', o.\"addressId\",\n        'status', o.status,\n        'total', o.total,\n        'note', n.note\n    ) INTO created_order\n    FROM orders o\n    LEFT JOIN order_notes n ON n.order_id = o.id\n    WHERE o.id = new_order_id;\n\n    RETURN created_order;\nEND;\n$function$\n"
}, {
  "proname": "create_flash_order_with_metadata",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.create_flash_order_with_metadata(order_data jsonb, metadata jsonb, note_text text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    new_order_id uuid;\n    created_order jsonb;\nBEGIN\n    -- Créer la commande flash\n    created_order := create_flash_order(order_data, note_text);\n    new_order_id := (created_order->>'id')::uuid;\n\n    -- Ajouter les métadonnées\n    IF metadata IS NOT NULL THEN\n        UPDATE orders\n        SET metadata = metadata\n        WHERE id = new_order_id;\n    END IF;\n\n    -- Retourner la commande mise à jour\n    SELECT jsonb_build_object(\n        'id', o.id,\n        'userId', o.\"userId\",\n        'serviceId', o.\"serviceId\",\n        'addressId', o.\"addressId\",\n        'status', o.status,\n        'total', o.total,\n        'metadata', o.metadata,\n        'note', n.note\n    ) INTO created_order\n    FROM orders o\n    LEFT JOIN order_notes n ON n.order_id = o.id\n    WHERE o.id = new_order_id;\n\n    RETURN created_order;\nEND;\n$function$\n"
}, {
  "proname": "get_paginated_orders",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.get_paginated_orders(p_page integer, p_limit integer, p_status text DEFAULT NULL::text, p_sort_field text DEFAULT 'created_at'::text, p_sort_order text DEFAULT 'desc'::text)\n RETURNS TABLE(data jsonb, total_count bigint)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    v_offset integer;\n    v_where text := 'WHERE 1=1';\n    v_order_by text;\nBEGIN\n    -- Calculer l'offset\n    v_offset := (p_page - 1) * p_limit;\n\n    -- Ajouter le filtre de statut si fourni\n    IF p_status IS NOT NULL THEN\n        v_where := v_where || format(' AND status = %L', p_status);\n    END IF;\n\n    -- Construire ORDER BY\n    v_order_by := format(' ORDER BY %I %s', p_sort_field, p_sort_order);\n\n    -- Retourner les résultats\n    RETURN QUERY EXECUTE format('\n        WITH ordered_orders AS (\n            SELECT \n                jsonb_build_object(\n                    ''id'', o.id,\n                    ''userId'', o.\"userId\",\n                    ''serviceId'', o.\"serviceId\",\n                    ''addressId'', o.\"addressId\",\n                    ''status'', o.status,\n                    ''total'', o.total,\n                    ''createdAt'', o.created_at,\n                    ''updatedAt'', o.updated_at,\n                    ''items'', COALESCE(\n                        jsonb_agg(\n                            jsonb_build_object(\n                                ''id'', oi.id,\n                                ''articleId'', oi.\"articleId\",\n                                ''quantity'', oi.quantity,\n                                ''unitPrice'', oi.\"unitPrice\"\n                            )\n                        ) FILTER (WHERE oi.id IS NOT NULL),\n                        ''[]''::jsonb\n                    )\n                ) as order_data\n            FROM orders o\n            LEFT JOIN order_items oi ON o.id = oi.\"orderId\"\n            %s\n            GROUP BY o.id\n            %s\n            LIMIT %s OFFSET %s\n        )\n        SELECT \n            array_to_json(array_agg(order_data))::jsonb as data,\n            (SELECT COUNT(*) FROM orders o %s) as total_count\n        FROM ordered_orders;\n    ', v_where, v_order_by, p_limit, v_offset, v_where);\nEND;\n$function$\n"
}, {
  "proname": "generate_functions_documentation",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.generate_functions_documentation()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    doc text := '# Documentation des Fonctions PostgreSQL' || E'\\n\\n';\r\n    func record;\r\n    current_level text := '';\r\nBEGIN\r\n    FOR func IN (\r\n        SELECT \r\n            n.nspname as schema,\r\n            p.proname as name,\r\n            pg_get_function_result(p.oid) as return_type,\r\n            pg_get_function_arguments(p.oid) as arguments,\r\n            d.description,\r\n            CASE \r\n                WHEN p.proname LIKE '%order%' THEN 'Gestion des Commandes'\r\n                WHEN p.proname LIKE '%article%' THEN 'Gestion des Articles'\r\n                WHEN p.proname LIKE '%loyalty%' THEN 'Gestion de la Fidélité'\r\n                WHEN p.proname LIKE '%affiliate%' THEN 'Gestion des Affiliés'\r\n                WHEN p.proname LIKE '%service%' THEN 'Gestion des Services'\r\n                ELSE 'Autres Fonctions'\r\n            END as category,\r\n            pg_get_functiondef(p.oid) as definition\r\n        FROM pg_proc p\r\n        LEFT JOIN pg_description d ON p.oid = d.objoid\r\n        LEFT JOIN pg_namespace n ON n.oid = p.pronamespace\r\n        WHERE n.nspname = 'public'\r\n        ORDER BY category, p.proname\r\n    )\r\n    LOOP\r\n        -- Ajouter un séparateur de catégorie si nécessaire\r\n        IF current_level != func.category THEN\r\n            current_level := func.category;\r\n            doc := doc || E'\\n## ' || current_level || E'\\n\\n';\r\n        END IF;\r\n\r\n        -- Ajouter les détails de la fonction\r\n        doc := doc || E'### `' || func.name || '`\\n\\n';\r\n        doc := doc || '**Signature:**\\n```sql\\n' || \r\n               func.name || '(' || func.arguments || ') RETURNS ' || func.return_type || \r\n               E'\\n```\\n\\n';\r\n\r\n        -- Description si disponible\r\n        IF func.description IS NOT NULL THEN\r\n            doc := doc || '**Description:**\\n' || func.description || E'\\n\\n';\r\n        END IF;\r\n\r\n        -- Ajouter le code source de la fonction\r\n        doc := doc || '**Implémentation:**\\n```sql\\n' || \r\n               func.definition || E'\\n```\\n\\n';\r\n\r\n        -- Ajouter un exemple d'utilisation\r\n        doc := doc || '**Exemple d''utilisation:**\\n```sql\\n';\r\n        CASE func.name\r\n            WHEN 'calculate_order_total' THEN\r\n                doc := doc || 'SELECT calculate_order_total(''uuid-de-commande'');';\r\n            WHEN 'get_paginated_orders' THEN\r\n                doc := doc || 'SELECT * FROM get_paginated_orders(1, 10, ''PENDING'', ''created_at'', ''desc'');';\r\n            ELSE\r\n                doc := doc || '-- Exemple à venir';\r\n        END CASE;\r\n        doc := doc || E'\\n```\\n\\n';\r\n\r\n        -- Ajouter un séparateur\r\n        doc := doc || '---\\n\\n';\r\n    END LOOP;\r\n\r\n    RETURN doc;\r\nEND;\r\n$function$\n"
}, {
  "proname": "update_orders_timestamp",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.update_orders_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.\"updatedAt\" = CURRENT_TIMESTAMP;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "proname": "update_service_timestamps",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.update_service_timestamps()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.updated_at = CURRENT_TIMESTAMP;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "proname": "insert_flash_order_note",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.insert_flash_order_note()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    INSERT INTO order_notes (\n        order_id,\n        note,\n        created_at,\n        updated_at\n    ) VALUES (\n        NEW.id,\n        'Commande flash créée',\n        CURRENT_TIMESTAMP,\n        CURRENT_TIMESTAMP\n    );\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "update_updated_at_column",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.updated_at = CURRENT_TIMESTAMP;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "proname": "validate_article_service_price_constraint",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.validate_article_service_price_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Vérification du type de prix\r\n    IF NEW.pricing_type NOT IN ('FIXED', 'WEIGHT_BASED', 'CUSTOM') THEN\r\n        RAISE EXCEPTION 'Type de prix invalide. Doit être FIXED, WEIGHT_BASED, ou CUSTOM';\r\n    END IF;\r\n\r\n    -- Vérification des prix négatifs\r\n    IF NEW.base_price < 0 OR (NEW.premium_price IS NOT NULL AND NEW.premium_price < 0) THEN\r\n        RAISE EXCEPTION 'Les prix ne peuvent pas être négatifs';\r\n    END IF;\r\n\r\n    -- Vérification du prix au kilo si applicable\r\n    IF NEW.pricing_type = 'WEIGHT_BASED' AND (NEW.price_per_kg IS NULL OR NEW.price_per_kg <= 0) THEN\r\n        RAISE EXCEPTION 'Prix au kilo requis et doit être positif pour le type WEIGHT_BASED';\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "proname": "validate_order_items_constraint",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.validate_order_items_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Vérification de la quantité\n    IF NEW.quantity <= 0 THEN\n        RAISE EXCEPTION 'La quantité doit être supérieure à zéro';\n    END IF;\n\n    -- Vérification du prix unitaire\n    IF NEW.\"unitPrice\" <= 0 THEN\n        RAISE EXCEPTION 'Le prix unitaire doit être supérieur à zéro';\n    END IF;\n\n    -- Vérification du poids si applicable\n    IF NEW.weight IS NOT NULL AND NEW.weight <= 0 THEN\n        RAISE EXCEPTION 'Le poids doit être supérieur à zéro';\n    END IF;\n\n    -- Calcul automatique du total\n    NEW.total = NEW.quantity * NEW.\"unitPrice\";\n    \n    -- Mise à jour du timestamp\n    NEW.updated_at = CURRENT_TIMESTAMP;\n\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "validate_price_ranges_constraint",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.validate_price_ranges_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Vérification du prix de base\r\n    IF NEW.base_price IS NOT NULL AND NEW.base_price < 0 THEN\r\n        RAISE EXCEPTION 'Le prix de base ne peut pas être négatif';\r\n    END IF;\r\n\r\n    -- Vérification du prix premium\r\n    IF NEW.premium_price IS NOT NULL AND NEW.premium_price < 0 THEN\r\n        RAISE EXCEPTION 'Le prix premium ne peut pas être négatif';\r\n    END IF;\r\n\r\n    -- Vérification de la cohérence des prix\r\n    IF NEW.premium_price IS NOT NULL AND NEW.base_price IS NOT NULL THEN\r\n        IF NEW.premium_price <= NEW.base_price THEN\r\n            RAISE EXCEPTION 'Le prix premium doit être supérieur au prix de base';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- Mise à jour automatique des timestamps\r\n    NEW.created_at = COALESCE(NEW.created_at, CURRENT_TIMESTAMP);\r\n    NEW.updated_at = CURRENT_TIMESTAMP;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "proname": "update_timestamp",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.update_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    IF TG_OP = 'UPDATE' THEN\r\n        NEW.updated_at = CURRENT_TIMESTAMP;\r\n    ELSE\r\n        -- Pour INSERT\r\n        NEW.created_at = COALESCE(NEW.created_at, CURRENT_TIMESTAMP);\r\n        NEW.updated_at = CURRENT_TIMESTAMP;\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "proname": "update_loyalty_points_timestamp",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.update_loyalty_points_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.\"updatedAt\" = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "validate_loyalty_points_constraint",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.validate_loyalty_points_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Vérification du solde de points positif\n    IF NEW.\"pointsBalance\" < 0 THEN\n        RAISE EXCEPTION 'Le solde de points ne peut pas être négatif';\n    END IF;\n\n    -- Vérification du total des points gagnés\n    IF NEW.\"totalEarned\" < 0 THEN\n        RAISE EXCEPTION 'Le total des points gagnés ne peut pas être négatif';\n    END IF;\n\n    -- Vérification de la cohérence\n    IF NEW.\"pointsBalance\" > NEW.\"totalEarned\" THEN\n        RAISE EXCEPTION 'Le solde actuel ne peut pas dépasser le total des points gagnés';\n    END IF;\n\n    -- Mise à jour automatique du timestamp en camelCase\n    NEW.\"updatedAt\" = CURRENT_TIMESTAMP;\n    \n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "validate_weight_range_constraint",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.validate_weight_range_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Log de début de validation\n    RAISE NOTICE 'Validation des plages de poids pour ID: %', NEW.id;\n\n    -- Vérification des valeurs minimales\n    IF NEW.min_weight IS NULL OR NEW.min_weight < 0 THEN\n        RAISE EXCEPTION 'Le poids minimum doit être positif';\n    END IF;\n\n    -- Vérification des valeurs maximales\n    IF NEW.max_weight IS NULL OR NEW.max_weight <= NEW.min_weight THEN\n        RAISE EXCEPTION 'Le poids maximum doit être supérieur au poids minimum (min: %)', NEW.min_weight;\n    END IF;\n\n    -- Vérification du prix par kg\n    IF NEW.price_per_kg <= 0 THEN\n        RAISE EXCEPTION 'Le prix par kg doit être positif';\n    END IF;\n\n    -- Vérification du chevauchement des plages\n    IF EXISTS (\n        SELECT 1 \n        FROM weight_based_pricing w\n        WHERE w.service_type_id = NEW.service_type_id\n        AND w.id != NEW.id\n        AND (\n            (NEW.min_weight BETWEEN w.min_weight AND w.max_weight)\n            OR (NEW.max_weight BETWEEN w.min_weight AND w.max_weight)\n        )\n    ) THEN\n        RAISE EXCEPTION 'Chevauchement détecté avec une plage existante';\n    END IF;\n\n    -- Mise à jour du timestamp\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    \n    RAISE NOTICE 'Validation réussie pour la plage: % - %kg', NEW.min_weight, NEW.max_weight;\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "validate_service_types_constraint",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.validate_service_types_constraint()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    IF NEW.pricing_type NOT IN ('FIXED', 'WEIGHT_BASED', 'CUSTOM') THEN\r\n        RAISE NOTICE 'Invalid pricing_type: %', NEW.pricing_type;\r\n        RAISE EXCEPTION 'Invalid pricing type. Must be FIXED, WEIGHT_BASED, or CUSTOM';\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "proname": "validate_article_service_price",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.validate_article_service_price()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Validation du prix de base\n    IF NEW.base_price < 0 THEN\n        RAISE EXCEPTION 'Le prix de base ne peut pas être négatif';\n    END IF;\n\n    -- Validation du prix premium\n    IF NEW.premium_price IS NOT NULL AND NEW.premium_price < 0 THEN\n        RAISE EXCEPTION 'Le prix premium ne peut pas être négatif';\n    END IF;\n\n    -- Validation du prix au kilo pour WEIGHT_BASED\n    IF NEW.pricing_type = 'WEIGHT_BASED' AND NEW.price_per_kg IS NULL THEN\n        RAISE EXCEPTION 'Prix au kilo requis pour le type WEIGHT_BASED';\n    END IF;\n\n    -- Mise à jour timestamp\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    \n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "validate_weight_pricing",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.validate_weight_pricing()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Validation des poids selon les valeurs par défaut du schema\n    IF NEW.min_weight < 0 THEN\n        RAISE EXCEPTION 'Le poids minimum doit être positif';\n    END IF;\n\n    IF NEW.max_weight <= NEW.min_weight THEN\n        RAISE EXCEPTION 'Le poids maximum doit être supérieur au minimum';\n    END IF;\n\n    IF NEW.max_weight > 999999 THEN\n        RAISE EXCEPTION 'Le poids maximum ne peut pas dépasser 999999';\n    END IF;\n\n    RETURN NEW;\nEND;\n$function$\n"
}, {
  "proname": "initialize_user_loyalty_points",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.initialize_user_loyalty_points()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    INSERT INTO loyalty_points (\r\n        id,\r\n        user_id,\r\n        \"pointsBalance\",\r\n        \"totalEarned\",\r\n        \"createdAt\",\r\n        \"updatedAt\"\r\n    )\r\n    VALUES (\r\n        gen_random_uuid(),\r\n        NEW.id,\r\n        0,\r\n        0,\r\n        CURRENT_TIMESTAMP,\r\n        CURRENT_TIMESTAMP\r\n    );\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
}, {
  "proname": "validate_loyalty_points",
  "pg_get_functiondef": "CREATE OR REPLACE FUNCTION public.validate_loyalty_points()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Validation du solde\n    IF NEW.\"pointsBalance\" < 0 THEN\n        RAISE EXCEPTION 'Le solde de points ne peut pas être négatif';\n    END IF;\n\n    -- Validation du total gagné\n    IF NEW.\"totalEarned\" < NEW.\"pointsBalance\" THEN\n        RAISE EXCEPTION 'Le solde ne peut pas dépasser le total gagné';\n    END IF;\n\n    -- Pas de mise à jour de timestamp - géré par Prisma\n    RETURN NEW;\nEND;\n$function$\n"
}]





[{
  "tgname": "set_timestamp",
  "tgrelid": "reset_codes",
  "pg_get_triggerdef": "CREATE TRIGGER set_timestamp BEFORE UPDATE ON public.reset_codes FOR EACH ROW EXECUTE FUNCTION trigger_set_timestamp()"
}, {
  "tgname": "create_user_loyalty_points",
  "tgrelid": "users",
  "pg_get_triggerdef": "CREATE TRIGGER create_user_loyalty_points AFTER INSERT ON public.users FOR EACH ROW EXECUTE FUNCTION initialize_user_loyalty_points()"
}, {
  "tgname": "after_point_transaction",
  "tgrelid": "point_transactions",
  "pg_get_triggerdef": "CREATE TRIGGER after_point_transaction AFTER INSERT ON public.point_transactions FOR EACH ROW EXECUTE FUNCTION update_loyalty_points_balance()"
}, {
  "tgname": "order_items_total_update",
  "tgrelid": "order_items",
  "pg_get_triggerdef": "CREATE TRIGGER order_items_total_update AFTER INSERT ON public.order_items FOR EACH ROW EXECUTE FUNCTION update_order_total()"
}, {
  "tgname": "order_note_sync_trigger",
  "tgrelid": "order_notes",
  "pg_get_triggerdef": "CREATE TRIGGER order_note_sync_trigger AFTER INSERT ON public.order_notes FOR EACH ROW EXECUTE FUNCTION sync_order_note()"
}, {
  "tgname": "update_orders_updated_at",
  "tgrelid": "orders",
  "pg_get_triggerdef": "CREATE TRIGGER update_orders_updated_at BEFORE UPDATE ON public.orders FOR EACH ROW EXECUTE FUNCTION update_orders_timestamp()"
}, {
  "tgname": "update_article_service_compatibility_timestamp",
  "tgrelid": "article_service_compatibility",
  "pg_get_triggerdef": "CREATE TRIGGER update_article_service_compatibility_timestamp BEFORE UPDATE ON public.article_service_compatibility FOR EACH ROW EXECUTE FUNCTION update_service_timestamps()"
}, {
  "tgname": "after_affiliate_earnings_update",
  "tgrelid": "affiliate_profiles",
  "pg_get_triggerdef": "CREATE TRIGGER after_affiliate_earnings_update AFTER UPDATE ON public.affiliate_profiles FOR EACH ROW EXECUTE FUNCTION trigger_update_affiliate_level()"
}, {
  "tgname": "order_metadata_timestamp",
  "tgrelid": "order_metadata",
  "pg_get_triggerdef": "CREATE TRIGGER order_metadata_timestamp BEFORE UPDATE ON public.order_metadata FOR EACH ROW EXECUTE FUNCTION update_timestamp()"
}, {
  "tgname": "order_weights_timestamp",
  "tgrelid": "order_weights",
  "pg_get_triggerdef": "CREATE TRIGGER order_weights_timestamp BEFORE UPDATE ON public.order_weights FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()"
}, {
  "tgname": "flash_order_note",
  "tgrelid": "orders",
  "pg_get_triggerdef": "CREATE TRIGGER flash_order_note AFTER INSERT ON public.orders FOR EACH ROW EXECUTE FUNCTION insert_flash_order_note()"
}, {
  "tgname": "update_offer_subscriptions_timestamp",
  "tgrelid": "offer_subscriptions",
  "pg_get_triggerdef": "CREATE TRIGGER update_offer_subscriptions_timestamp BEFORE UPDATE ON public.offer_subscriptions FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()"
}, {
  "tgname": "update_offers_timestamp",
  "tgrelid": "offers",
  "pg_get_triggerdef": "CREATE TRIGGER update_offers_timestamp BEFORE UPDATE ON public.offers FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()"
}, {
  "tgname": "update_subscription_plans_timestamp",
  "tgrelid": "subscription_plans",
  "pg_get_triggerdef": "CREATE TRIGGER update_subscription_plans_timestamp BEFORE UPDATE ON public.subscription_plans FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()"
}, {
  "tgname": "ensure_valid_order_items",
  "tgrelid": "order_items",
  "pg_get_triggerdef": "CREATE TRIGGER ensure_valid_order_items BEFORE INSERT OR UPDATE ON public.order_items FOR EACH ROW EXECUTE FUNCTION validate_order_items_constraint()"
}, {
  "tgname": "ensure_valid_weight_range",
  "tgrelid": "weight_based_pricing",
  "pg_get_triggerdef": "CREATE TRIGGER ensure_valid_weight_range BEFORE INSERT OR UPDATE ON public.weight_based_pricing FOR EACH ROW EXECUTE FUNCTION validate_weight_range_constraint()"
}, {
  "tgname": "ensure_valid_service_type",
  "tgrelid": "service_types",
  "pg_get_triggerdef": "CREATE TRIGGER ensure_valid_service_type BEFORE INSERT OR UPDATE ON public.service_types FOR EACH ROW EXECUTE FUNCTION validate_service_types_constraint()"
}, {
  "tgname": "update_service_types_timestamp",
  "tgrelid": "service_types",
  "pg_get_triggerdef": "CREATE TRIGGER update_service_types_timestamp BEFORE UPDATE ON public.service_types FOR EACH ROW EXECUTE FUNCTION update_timestamp()"
}, {
  "tgname": "validate_article_service_price_trigger",
  "tgrelid": "article_service_prices",
  "pg_get_triggerdef": "CREATE TRIGGER validate_article_service_price_trigger BEFORE INSERT OR UPDATE ON public.article_service_prices FOR EACH ROW EXECUTE FUNCTION validate_article_service_price()"
}, {
  "tgname": "update_loyalty_points_timestamp",
  "tgrelid": "loyalty_points",
  "pg_get_triggerdef": "CREATE TRIGGER update_loyalty_points_timestamp BEFORE INSERT OR UPDATE ON public.loyalty_points FOR EACH ROW EXECUTE FUNCTION update_loyalty_points_timestamp()"
}, {
  "tgname": "ensure_valid_loyalty_points",
  "tgrelid": "loyalty_points",
  "pg_get_triggerdef": "CREATE TRIGGER ensure_valid_loyalty_points BEFORE INSERT OR UPDATE ON public.loyalty_points FOR EACH ROW EXECUTE FUNCTION validate_loyalty_points_constraint()"
}, {
  "tgname": "update_articles_timestamp",
  "tgrelid": "articles",
  "pg_get_triggerdef": "CREATE TRIGGER update_articles_timestamp BEFORE UPDATE ON public.articles FOR EACH ROW EXECUTE FUNCTION update_timestamp_column()"
}]
